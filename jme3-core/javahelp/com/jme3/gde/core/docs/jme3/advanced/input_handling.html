
<h1><a>Input Handling</a></h1>
<div>

<p>

Users interact with your jME3 application with different input devices – the mouse, the keyboard, or a joystick. To respond to inputs we use the <code>inputManager</code> object in <code>SimpleApplication</code>.
</p>

<p>
This is how you add interaction to your game:

</p>
<ol>
<li><div> For each action, choose the trigger(s) (a key or mouse click etc)</div>
</li>
<li><div> For each action, add a trigger mapping to the inputManager</div>
</li>
<li><div> Create at least one listener in SimpleApplication</div>
</li>
<li><div> For each action, register its mappings to a listener</div>
</li>
<li><div> Implement each action in the listener</div>
</li>
</ol>

</div>

<h2><a>1. Choose Trigger</a></h2>
<div>

<p>

Choose one or several key/mouse events for the interaction. We use <code>KeyTrigger</code>, <code>MouseAxisTrigger</code>, <code>MouseButtonTrigger</code>, <code>JoyAxisTrigger</code> and <code>JoyButtonTrigger</code> constants from the <code>com.jme3.input.controls</code> package. 
</p>

<p>
The booleans are used to negate the axes: For inputs that have two axes (MouseAxis, JoyAxis), you have to listen to the negative (true) and positive (false) axis separately.

</p>
<table>
	<tr>
		<th> Trigger </th><th> Code </th>
	</tr>
	<tr>
		<td> Mouse button: Left Click </td><td> MouseButtonTrigger(MouseInput.BUTTON_LEFT) </td>
	</tr>
	<tr>
		<td> Mouse button: Right Click </td><td> MouseButtonTrigger(MouseInput.BUTTON_RIGHT) </td>
	</tr>
	<tr>
		<td> Mouse button: Middle Click </td><td> MouseButtonTrigger(MouseInput.BUTTON_MIDDLE) </td>
	</tr>
	<tr>
		<td> Mouse movement: </td><td> MouseAxisTrigger(MouseInput.AXIS_X, true), <br/>
 MouseAxisTrigger(MouseInput.AXIS_Y, true), <br/>
 MouseAxisTrigger(MouseInput.AXIS_X, false), <br/>
 MouseAxisTrigger(MouseInput.AXIS_Y, false) </td>
	</tr>
	<tr>
		<td> Mouse wheel: </td><td> MouseAxisTrigger(MouseInput.AXIS_WHEEL,false) <br/>
  MouseAxisTrigger(MouseInput.AXIS_WHEEL,true) </td>
	</tr>
	<tr>
		<td> Keyboard: Characters and Numbers etc </td><td> KeyTrigger(KeyInput.KEY_X) etc </td>
	</tr>
	<tr>
		<td> Keyboard: Spacebar  </td><td> KeyTrigger(KeyInput.KEY_SPACE) </td>
	</tr>
	<tr>
		<td> Keyboard: Shift </td><td> KeyTrigger(KeyInput.KEY_RSHIFT), <br/>
 KeyTrigger(KeyInput.KEY_LSHIFT) </td>
	</tr>
	<tr>
		<td> Keyboard: F1 etc </td><td> KeyTrigger(KeyInput.KEY_F1) etc </td>
	</tr>
	<tr>
		<td> Keyboard: Return, Enter </td><td> KeyTrigger(KeyInput.KEY_RETURN), <br/>
 KeyTrigger(KeyInput.KEY_NUMPADENTER)  </td>
	</tr>
	<tr>
		<td> Keyboard: PageUp, PageDown </td><td> KeyTrigger(KeyInput.KEY_PGUP), <br/>
 KeyTrigger(KeyInput.KEY_PGDN) </td>
	</tr>
	<tr>
		<td> Keyboard: Delete, Backspace </td><td> KeyTrigger(KeyInput.KEY_BACK), <br/>
 KeyTrigger(KeyInput.KEY_DELETE) </td>
	</tr>
	<tr>
		<td> Keyboard: Escape </td><td> KeyTrigger(KeyInput.KEY_ESCAPE) </td>
	</tr>
	<tr>
		<td> Keyboard: Arrows </td><td> KeyTrigger(KeyInput.KEY_DOWN), <br/>
 KeyTrigger(KeyInput.KEY_UP) <br/>
 KeyTrigger(KeyInput.KEY_LEFT), KeyTrigger(KeyInput.KEY_RIGHT) </td>
	</tr>
	<tr>
		<td> NumPad: Number 1 etc </td><td> KeyTrigger(KeyInput.KEY_NUMPAD1) etc </td>
	</tr>
	<tr>
		<td> Joystick: Button </td><td> JoyButtonTrigger(0, JoyInput.AXIS_POV_X), <br/>
 JoyButtonTrigger(0, JoyInput.AXIS_POV_Y) ? </td>
	</tr>
	<tr>
		<td> Joystick: Movement </td><td> JoyAxisTrigger(0, JoyInput.AXIS_POV_X, true), <br/>
 JoyAxisTrigger(0, JoyInput.AXIS_POV_X, false), <br/>
 JoyAxisTrigger(0, JoyInput.AXIS_POV_Z, true),  <br/>
 JoyAxisTrigger(0, JoyInput.AXIS_POV_Z, false) </td>
	</tr>
</table>

</div>

<h2><a>2. Add a Trigger Mapping</a></h2>
<div>

<p>

When initializing the application, add a Mapping for each Trigger. 
</p>

<p>
Give the mapping a meaningful name. The name should reflect the action, not the key, since the keys can change. Here some examples:
</p>
<pre>inputManager.addMapping&#40;&quot;Pause Game&quot;, new KeyTrigger&#40;KeyInput.KEY_P&#41;&#41;;
inputManager.addMapping&#40;&quot;Rotate&quot;,     new KeyTrigger&#40;KeyInput.KEY_SPACE&#41;&#41;;</pre>
<p>
There are cases where you may want more then one trigger for one action. For instance some users prefer the WASD keys to navigate, others prefer the arrow keys. You can define both by adding them after a comma.
</p>
<pre>inputManager.addMapping&#40;&quot;Left&quot;,  new KeyTrigger&#40;KeyInput.KEY_A&#41;, 
                                 new KeyTrigger&#40;KeyInput.KEY_LEFT&#41;&#41;;
inputManager.addMapping&#40;&quot;Right&quot;, new KeyTrigger&#40;KeyInput.KEY_D&#41;, 
                                 new KeyTrigger&#40;KeyInput.KEY_RIGHT&#41;&#41;;</pre>
</div>

<h2><a>3. Create Listeners</a></h2>
<div>

<p>

The jME3 input manager supports two types of event listeners for inputs:
</p>

<p>
<strong>com.jme3.input.controls.AnalogListener</strong>
</p>
<ul>
<li><div> Use for continuous and gradual actions.</div>
<ul>
<li><div> Examples: Walk, run, rotate, accelerate vehicle, strafe, (semi-)automatic weapon shot</div>
</li>
</ul>
</li>
<li><div> JME gives you access to:</div>
<ul>
<li><div> the name of the triggered action.</div>
</li>
<li><div> a gradual value between 0-9 how long the key has been pressed.</div>
</li>
</ul>
</li>
</ul>

<p>

<strong>com.jme3.input.controls.ActionListener</strong>
</p>
<ul>
<li><div> Use for absolute “pressed or released?”, “on or off?” actions. </div>
<ul>
<li><div> Examples: Pause/unpause, a rifle or revolver shot, jump, click to select.</div>
</li>
</ul>
</li>
<li><div> JME gives you access to:</div>
<ul>
<li><div> the name of the triggered action.</div>
</li>
<li><div> a boolean whether the key is still pressed or has just been released.</div>
</li>
</ul>
</li>
</ul>

<p>

You can use one or both in the same application. Add one or both of these code snippets to your main SimpleApplication-based class to activate the listener.
</p>
<pre>private ActionListener&#40;&#41; &#123;
  public void onAction&#40;String name, boolean keyPressed, float tpf&#41; &#123;
     /** TODO */
  &#125;
&#125;;</pre><pre>private AnalogListener analogListener = new AnalogListener&#40;&#41; &#123;
  public void onAnalog&#40;String name, float keyPressed, float tpf&#41; &#123;
     /** TODO */
  &#125;
&#125;;</pre>
</div>

<h2><a>4. Register Mappings to Listeners</a></h2>
<div>

<p>

To activate the mappings, you must register them to the Listener. Write your registration code after the part where you have added the mappings to the inputManager before.
</p>

<p>
In this example, we register the “Pause Game” mapping to the <code>actionListener</code> object, because pausing a game is in “either/or” decision.
</p>
<pre>inputManager.addListener&#40;actionListener, new String&#91;&#93;&#123;&quot;Pause Game&quot;&#125;&#41;;</pre>
<p>
In this example, we register navigational mappings to the <code>analogListener</code> object, because walking is a continuous action. Players tend to keep the key pressed to express continuity, for example when they want to “walk on” or “accelerate”.
</p>
<pre>inputManager.addListener&#40;analogListener, new String&#91;&#93;&#123;&quot;Left&quot;, &quot;Right&quot;&#125;&#41;;</pre>
<p>
As you see, you can add several listeners in one String array. You can call the addListener() method more than once, each time with a subset of your list, if that helps you keep you code tidy.
</p>

<p>
<strong>Tip:</strong> Check the string&#039;s capitalization and spelling if you think you have registered an action, but it does not work.
</p>

</div>

<h2><a>5. Implement Actions</a></h2>
<div>

<p>

You specify the action to be triggered where it says TODO in the Listener code snippets.
Typically you write a series of if/else conditions, testing for all the mapping names, and specifying each action. Here is one example:
</p>
<pre>private AnalogListener analogListener = new AnalogListener&#40;&#41; &#123;
    public void onAnalog&#40;String name, float value, float tpf&#41; &#123;
&nbsp;
      if &#40;name.equals&#40;&quot;Rotate&quot;&#41;&#41; &#123;         // test?
        player.rotate&#40;0, value*speed, 0&#41;;  // action!
      &#125; // else if ...
&nbsp;
    &#125;
  &#125;;</pre>
<p>
It&#039;s very common that you want an action to be only triggered once, in the moment when the key is released. Examples are when the player presses an action key to open a door or pick up an item, or to flip a game state, such as pause/unpause. For these cases, use an ActionListener and test for <code>&amp;&amp; !keyPressed</code>, like shown in the following example. 
</p>
<pre>private ActionListener&#40;&#41; &#123;
    public void onAction&#40;String name, boolean keyPressed, float tpf&#41; &#123;
&nbsp;
      if &#40;name.equals&#40;&quot;Pause Game&quot;&#41; &amp;&amp; !keyPressed&#41; &#123; // test?
        isRunning = !isRunning;                       // action!
      &#125; // else if ...
&nbsp;
    &#125;
  &#125;;</pre>
</div>

<h2><a>Remapping Keys</a></h2>
<div>

<p>

This approach of separating triggers from actions has the advantage that you can remap triggers easily. Maybe your players have different keyboard layouts, are used to “reversed” mouse navigation, or prefer different navigational keys than the ones you defined. In any case, you only need to replace the trigger parts in the <code>inputManager.addMapping()</code> lines with variables, and load different sets of trigger objects when the game starts. The rest of the code stays as it is.
</p>

</div>
<p><em><a href="http://jmonkeyengine.org/wiki/doku.php/jme3:advanced:input_handling?do=export_xhtmlbody">view online version</a></em></p>