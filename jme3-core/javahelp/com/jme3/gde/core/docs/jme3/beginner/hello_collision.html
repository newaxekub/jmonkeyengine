


<h1><a name="getting_started_with_jme3_9_-_hello_collision" id="getting_started_with_jme3_9_-_hello_collision">Getting Started with JME3 (9) - Hello Collision</a></h1>
<div class="level1">

<p>

Previous: <a href="/com/jme3/gde/core/docs/jme3/beginner/hello_picking.html" class="wikilink1" title="jme3:beginner:hello_picking">Hello Picking</a>,
Next: <a href="/com/jme3/gde/core/docs/jme3/beginner/hello_audio.html" class="wikilink1" title="jme3:beginner:hello_audio">Hello Audio</a>
</p>

<p>
This tutorial demonstrates how you load a scene model and give it solid walls and floors for a character to walk around.
</p>

<p>
We will use a <code>PhysicsNode</code> for the static collidable scene, and a <code>PhysicsCharacterNode</code> for the mobile first-person character. We will also adapt the default first-person camera to work with physics-controlled navigation. 
</p>

<p>
The solution shown here can be used for first-person shooters, mazes, and similar games. 
</p>

<p>
<img src="nbdocs:/com/jme3/gde/core/docs/jme3/beginner/beginner-scene.png">
</p>

</div>
<!-- SECTION "Getting Started with JME3 (9) - Hello Collision" [1-592] -->
<h2><a name="sample_code" id="sample_code">Sample Code</a></h2>
<div class="level2">

<p>

If you don&#039;t have it yet, <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://jmonkeyengine.googlecode.com/svn/branches/jme3/town.zip"><param name="text" value="<html><u>download the town.zip</u></html>"><param name="textColor" value="blue"></object> sample scene. Place it in the root directory of your JME3 project:
</p>
<pre class="code">jMonkeyProjects$ ls -1 BasicGame
assets
build.xml
town.zip
src</pre>
<pre class="code java"><span class="kw1">package</span> <span class="co2">jme3test.helloworld</span>;
&nbsp;
<span class="kw1">import</span> <span class="co2">com.jme3.app.SimpleApplication</span>;
<span class="kw1">import</span> <span class="co2">com.jme3.asset.plugins.ZipLocator</span>;
<span class="kw1">import</span> <span class="co2">com.jme3.bullet.BulletAppState</span>;
<span class="kw1">import</span> <span class="co2">com.jme3.bullet.collision.shapes.CapsuleCollisionShape</span>;
<span class="kw1">import</span> <span class="co2">com.jme3.bullet.collision.shapes.CompoundCollisionShape</span>;
<span class="kw1">import</span> <span class="co2">com.jme3.bullet.nodes.PhysicsCharacterNode</span>;
<span class="kw1">import</span> <span class="co2">com.jme3.bullet.nodes.PhysicsNode</span>;
<span class="kw1">import</span> <span class="co2">com.jme3.bullet.util.CollisionShapeFactory</span>;
<span class="kw1">import</span> <span class="co2">com.jme3.input.KeyInput</span>;
<span class="kw1">import</span> <span class="co2">com.jme3.input.controls.ActionListener</span>;
<span class="kw1">import</span> <span class="co2">com.jme3.input.controls.KeyTrigger</span>;
<span class="kw1">import</span> <span class="co2">com.jme3.light.DirectionalLight</span>;
<span class="kw1">import</span> <span class="co2">com.jme3.math.ColorRGBA</span>;
<span class="kw1">import</span> <span class="co2">com.jme3.math.Vector3f</span>;
<span class="kw1">import</span> <span class="co2">com.jme3.scene.Node</span>;
<span class="kw1">import</span> <span class="co2">com.jme3.scene.Spatial</span>;
&nbsp;
<span class="co3">/**
 * Example 9 - How to make walls and floors solid.
 * This version uses Physics and a custom Action Listener.
 * @author normen, with edits by Zathras
 */</span>
<span class="kw1">public</span> <span class="kw1">class</span> HelloCollision <span class="kw1">extends</span> SimpleApplication <span class="kw1">implements</span> <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://www.google.com/search?hl=en&amp;q=allinurl%3Aactionlistener+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky"><param name="text" value="<html><u></u></html>"><param name="textColor" value="blue"></object> <span class="br0">&#123;</span>
&nbsp;
  <span class="kw1">private</span> BulletAppState bulletAppState;
  <span class="kw1">private</span> Spatial sceneModel;
  <span class="kw1">private</span> PhysicsNode landscape;
  <span class="kw1">private</span> PhysicsCharacterNode player;
  <span class="kw1">private</span> Vector3f walkDirection <span class="sy0">=</span> <span class="kw1">new</span> Vector3f<span class="br0">&#40;</span><span class="br0">&#41;</span>;
  <span class="kw1">private</span> <span class="kw4">boolean</span> left <span class="sy0">=</span> <span class="kw2">false</span>, right <span class="sy0">=</span> <span class="kw2">false</span>, up <span class="sy0">=</span> <span class="kw2">false</span>, down <span class="sy0">=</span> <span class="kw2">false</span>;
&nbsp;
  <span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">void</span> main<span class="br0">&#40;</span><object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://www.google.com/search?hl=en&amp;q=allinurl%3Astring+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky"><param name="text" value="<html><u></u></html>"><param name="textColor" value="blue"></object><span class="br0">&#91;</span><span class="br0">&#93;</span> args<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    HelloCollision app <span class="sy0">=</span> <span class="kw1">new</span> HelloCollision<span class="br0">&#40;</span><span class="br0">&#41;</span>;
    app.<span class="me1">start</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>
&nbsp;
  <span class="kw1">public</span> <span class="kw4">void</span> simpleInitApp<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="co3">/** Set up Physics */</span>
    bulletAppState <span class="sy0">=</span> <span class="kw1">new</span> BulletAppState<span class="br0">&#40;</span><span class="br0">&#41;</span>;
    stateManager.<span class="me1">attach</span><span class="br0">&#40;</span>bulletAppState<span class="br0">&#41;</span>;
&nbsp;
    <span class="co1">// We re-use the flyby camera for rotation, while positioning is handled by physics</span>
    viewPort.<span class="me1">setBackgroundColor</span><span class="br0">&#40;</span><span class="kw1">new</span> ColorRGBA<span class="br0">&#40;</span>0.7f,0.8f,1f,1f<span class="br0">&#41;</span><span class="br0">&#41;</span>;
    flyCam.<span class="me1">setMoveSpeed</span><span class="br0">&#40;</span><span class="nu0">100</span><span class="br0">&#41;</span>;
    setupKeys<span class="br0">&#40;</span><span class="br0">&#41;</span>;
&nbsp;
    <span class="co1">// We add a light so we see the scene</span>
    DirectionalLight dl <span class="sy0">=</span> <span class="kw1">new</span> DirectionalLight<span class="br0">&#40;</span><span class="br0">&#41;</span>;
    dl.<span class="me1">setColor</span><span class="br0">&#40;</span>ColorRGBA.<span class="me1">White</span>.<span class="me1">clone</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">multLocal</span><span class="br0">&#40;</span><span class="nu0">2</span><span class="br0">&#41;</span><span class="br0">&#41;</span>; <span class="co1">// bright white light</span>
    dl.<span class="me1">setDirection</span><span class="br0">&#40;</span><span class="kw1">new</span> Vector3f<span class="br0">&#40;</span>2.8f, <span class="sy0">-</span>2.8f, <span class="sy0">-</span>2.8f<span class="br0">&#41;</span>.<span class="me1">normalize</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
    rootNode.<span class="me1">addLight</span><span class="br0">&#40;</span>dl<span class="br0">&#41;</span>;
&nbsp;
    <span class="co1">// We load the scene from the zip file and adjust its size.</span>
    assetManager.<span class="me1">registerLocator</span><span class="br0">&#40;</span><span class="st0">&quot;town.zip&quot;</span>, ZipLocator.<span class="kw1">class</span>.<span class="me1">getName</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
    sceneModel <span class="sy0">=</span> assetManager.<span class="me1">loadModel</span><span class="br0">&#40;</span><span class="st0">&quot;main.scene&quot;</span><span class="br0">&#41;</span>;
    sceneModel.<span class="me1">setLocalScale</span><span class="br0">&#40;</span>2f<span class="br0">&#41;</span>;
&nbsp;
    <span class="co1">// We set up collision detection for the scene by creating a</span>
    <span class="co1">// compound collision shape and a physics node.</span>
    CompoundCollisionShape sceneShape <span class="sy0">=</span> 
      CollisionShapeFactory.<span class="me1">createMeshCompoundShape</span><span class="br0">&#40;</span><span class="br0">&#40;</span>Node<span class="br0">&#41;</span> sceneModel<span class="br0">&#41;</span>;
    landscape <span class="sy0">=</span> <span class="kw1">new</span> PhysicsNode<span class="br0">&#40;</span>sceneModel, sceneShape, 0<span class="br0">&#41;</span>;
&nbsp;
    <span class="co1">// We set up collision detection for the player by creating</span>
    <span class="co1">// a capsule collision shape and a physics character node.</span>
    <span class="co1">// The physics character node offers extra settings for</span>
    <span class="co1">// size, stepheight, jumping, falling, and gravity.</span>
    <span class="co1">// We also put the player in its starting position.</span>
    player <span class="sy0">=</span> <span class="kw1">new</span> PhysicsCharacterNode<span class="br0">&#40;</span><span class="kw1">new</span> CapsuleCollisionShape<span class="br0">&#40;</span>1.5f, 6f, <span class="nu0">1</span><span class="br0">&#41;</span>, .05f<span class="br0">&#41;</span>;
    player.<span class="me1">setJumpSpeed</span><span class="br0">&#40;</span><span class="nu0">20</span><span class="br0">&#41;</span>;
    player.<span class="me1">setFallSpeed</span><span class="br0">&#40;</span><span class="nu0">30</span><span class="br0">&#41;</span>;
    player.<span class="me1">setGravity</span><span class="br0">&#40;</span><span class="nu0">30</span><span class="br0">&#41;</span>;
    player.<span class="me1">setLocalTranslation</span><span class="br0">&#40;</span><span class="kw1">new</span> Vector3f<span class="br0">&#40;</span>0, <span class="nu0">10</span>, 0<span class="br0">&#41;</span><span class="br0">&#41;</span>;
&nbsp;
    <span class="co1">// We attach the scene and the player to the rootnode and the physics space,</span>
    <span class="co1">// to make them appear in the game world.</span>
    rootNode.<span class="me1">attachChild</span><span class="br0">&#40;</span>landscape<span class="br0">&#41;</span>;
    rootNode.<span class="me1">attachChild</span><span class="br0">&#40;</span>player<span class="br0">&#41;</span>;
    bulletAppState.<span class="me1">getPhysicsSpace</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">add</span><span class="br0">&#40;</span>landscape<span class="br0">&#41;</span>;
    bulletAppState.<span class="me1">getPhysicsSpace</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">add</span><span class="br0">&#40;</span>player<span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>
&nbsp;
  <span class="co3">/** We over-write some navigational key mappings here, so we can
   * add physics-controlled walking and jumping: */</span>
  <span class="kw1">private</span> <span class="kw4">void</span> setupKeys<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    inputManager.<span class="me1">addMapping</span><span class="br0">&#40;</span><span class="st0">&quot;Lefts&quot;</span>,  <span class="kw1">new</span> KeyTrigger<span class="br0">&#40;</span>KeyInput.<span class="me1">KEY_A</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
    inputManager.<span class="me1">addMapping</span><span class="br0">&#40;</span><span class="st0">&quot;Rights&quot;</span>, <span class="kw1">new</span> KeyTrigger<span class="br0">&#40;</span>KeyInput.<span class="me1">KEY_D</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
    inputManager.<span class="me1">addMapping</span><span class="br0">&#40;</span><span class="st0">&quot;Ups&quot;</span>,    <span class="kw1">new</span> KeyTrigger<span class="br0">&#40;</span>KeyInput.<span class="me1">KEY_W</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
    inputManager.<span class="me1">addMapping</span><span class="br0">&#40;</span><span class="st0">&quot;Downs&quot;</span>,  <span class="kw1">new</span> KeyTrigger<span class="br0">&#40;</span>KeyInput.<span class="me1">KEY_S</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
    inputManager.<span class="me1">addMapping</span><span class="br0">&#40;</span><span class="st0">&quot;Jumps&quot;</span>,  <span class="kw1">new</span> KeyTrigger<span class="br0">&#40;</span>KeyInput.<span class="me1">KEY_SPACE</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
    inputManager.<span class="me1">addListener</span><span class="br0">&#40;</span><span class="kw1">this</span>, <span class="st0">&quot;Lefts&quot;</span><span class="br0">&#41;</span>;
    inputManager.<span class="me1">addListener</span><span class="br0">&#40;</span><span class="kw1">this</span>, <span class="st0">&quot;Rights&quot;</span><span class="br0">&#41;</span>;
    inputManager.<span class="me1">addListener</span><span class="br0">&#40;</span><span class="kw1">this</span>, <span class="st0">&quot;Ups&quot;</span><span class="br0">&#41;</span>;
    inputManager.<span class="me1">addListener</span><span class="br0">&#40;</span><span class="kw1">this</span>, <span class="st0">&quot;Downs&quot;</span><span class="br0">&#41;</span>;
    inputManager.<span class="me1">addListener</span><span class="br0">&#40;</span><span class="kw1">this</span>, <span class="st0">&quot;Jumps&quot;</span><span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>
&nbsp;
  <span class="co3">/** These are our custom actions triggered by key presses.
   * We do not walk yet, we just keep track of the direction the user pressed. */</span>
  <span class="kw1">public</span> <span class="kw4">void</span> onAction<span class="br0">&#40;</span><object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://www.google.com/search?hl=en&amp;q=allinurl%3Astring+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky"><param name="text" value="<html><u></u></html>"><param name="textColor" value="blue"></object> binding, <span class="kw4">boolean</span> value, <span class="kw4">float</span> tpf<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>binding.<span class="me1">equals</span><span class="br0">&#40;</span><span class="st0">&quot;Lefts&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span> left <span class="sy0">=</span> <span class="kw2">true</span>; <span class="br0">&#125;</span>  <span class="kw1">else</span> <span class="br0">&#123;</span> left <span class="sy0">=</span> <span class="kw2">false</span>; <span class="br0">&#125;</span>
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>binding.<span class="me1">equals</span><span class="br0">&#40;</span><span class="st0">&quot;Rights&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span> right <span class="sy0">=</span> <span class="kw2">true</span>; <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span> right <span class="sy0">=</span> <span class="kw2">false</span>; <span class="br0">&#125;</span>
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>binding.<span class="me1">equals</span><span class="br0">&#40;</span><span class="st0">&quot;Ups&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span> up <span class="sy0">=</span> <span class="kw2">true</span>; <span class="br0">&#125;</span>    <span class="kw1">else</span> <span class="br0">&#123;</span> up <span class="sy0">=</span> <span class="kw2">false</span>; <span class="br0">&#125;</span>
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>binding.<span class="me1">equals</span><span class="br0">&#40;</span><span class="st0">&quot;Downs&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span> down <span class="sy0">=</span> <span class="kw2">true</span>; <span class="br0">&#125;</span>  <span class="kw1">else</span> <span class="br0">&#123;</span> down <span class="sy0">=</span> <span class="kw2">false</span>; <span class="br0">&#125;</span>
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>binding.<span class="me1">equals</span><span class="br0">&#40;</span><span class="st0">&quot;Jumps&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      player.<span class="me1">jump</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>
&nbsp;
  <span class="co3">/**
   * This is the main event loop--walking happens here.
   * We check in which direction the player is walking by interpreting
   * the camera direction forward (camDir) and to the side (camLeft).
   * The setWalkDirection() command is what lets a physics-controlled player walk.
   * We also make sure here that the camera moves with player.
   */</span>
  @Override
  <span class="kw1">public</span> <span class="kw4">void</span> simpleUpdate<span class="br0">&#40;</span><span class="kw4">float</span> tpf<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    Vector3f camDir <span class="sy0">=</span> cam.<span class="me1">getDirection</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">clone</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">multLocal</span><span class="br0">&#40;</span>0.6f<span class="br0">&#41;</span>;
    Vector3f camLeft <span class="sy0">=</span> cam.<span class="me1">getLeft</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">clone</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">multLocal</span><span class="br0">&#40;</span>0.4f<span class="br0">&#41;</span>;
    walkDirection.<span class="me1">set</span><span class="br0">&#40;</span>0, 0, 0<span class="br0">&#41;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>left<span class="br0">&#41;</span>  <span class="br0">&#123;</span> walkDirection.<span class="me1">addLocal</span><span class="br0">&#40;</span>camLeft<span class="br0">&#41;</span>; <span class="br0">&#125;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>right<span class="br0">&#41;</span> <span class="br0">&#123;</span> walkDirection.<span class="me1">addLocal</span><span class="br0">&#40;</span>camLeft.<span class="me1">negate</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>up<span class="br0">&#41;</span>    <span class="br0">&#123;</span> walkDirection.<span class="me1">addLocal</span><span class="br0">&#40;</span>camDir<span class="br0">&#41;</span>; <span class="br0">&#125;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>down<span class="br0">&#41;</span>  <span class="br0">&#123;</span> walkDirection.<span class="me1">addLocal</span><span class="br0">&#40;</span>camDir.<span class="me1">negate</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span>
    player.<span class="me1">setWalkDirection</span><span class="br0">&#40;</span>walkDirection<span class="br0">&#41;</span>;
    cam.<span class="me1">setLocation</span><span class="br0">&#40;</span>player.<span class="me1">getLocalTranslation</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
Run the sample. You should see a town square with houses and a monument. Use the WASD keys and the mouse to navigate around in first person view. Run forward and jump by pressing W and Space. Note how you step over the sidewalk, and up the steps to the monument. You can walk in the alleys between the houses, but the walls are solid. Don&#039;t walk over the edge of the world! <img src="/wiki/lib/images/smileys/icon_smile.gif" class="middle" alt=":-)" />
</p>

</div>
<!-- SECTION "Sample Code" [593-6871] -->
<h2><a name="understanding_the_code" id="understanding_the_code">Understanding the Code</a></h2>
<div class="level2">

<p>

Let&#039;s start with the class declaration: 
</p>
<pre class="code java"><span class="kw1">extends</span> SimpleApplication <span class="kw1">implements</span> <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://www.google.com/search?hl=en&amp;q=allinurl%3Aactionlistener+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky"><param name="text" value="<html><u></u></html>"><param name="textColor" value="blue"></object></pre>
<p>
SimpleApplication is the base class for all jME3 games. We also have this class implement the <code>ActionListener</code> interface because we want to customize the navigational inputs later.
</p>
<pre class="code java">  <span class="kw1">private</span> BulletAppState bulletAppState;
  <span class="kw1">private</span> Spatial sceneModel;
  <span class="kw1">private</span> PhysicsNode landscape;
  <span class="kw1">private</span> PhysicsCharacterNode player;
  <span class="kw1">private</span> Vector3f walkDirection <span class="sy0">=</span> <span class="kw1">new</span> Vector3f<span class="br0">&#40;</span><span class="br0">&#41;</span>;
  <span class="kw1">private</span> <span class="kw4">boolean</span> left <span class="sy0">=</span> <span class="kw2">false</span>, right <span class="sy0">=</span> <span class="kw2">false</span>, up <span class="sy0">=</span> <span class="kw2">false</span>, down <span class="sy0">=</span> <span class="kw2">false</span>;</pre>
<p>
We initialize a few private fields:
</p>
<ul>
<li class="level1"><div class="li"> The BulletAppState gives this SimpleApplication access to physics features (such as collision detection) supplied by jME3&#039;s jBullet integration</div>
</li>
<li class="level1"><div class="li"> The sceneModel is a normal OgreXML model loaded as a Spatial. </div>
</li>
<li class="level1"><div class="li"> You use the model as the game&#039;s landscape by wrapping it in a <code>PhysicsNode</code>. </div>
</li>
<li class="level1"><div class="li"> The (invisible) first-person player is represented by a <code>PhysicsCharacterNode</code>.</div>
</li>
<li class="level1"><div class="li"> The fields <code>walkDirection</code> and the four Booleans are used for physics-controlled navigation. </div>
</li>
</ul>

<p>

Let&#039;s have a look at all the details:
</p>

</div>
<!-- SECTION "Understanding the Code" [6872-8053] -->
<h2><a name="initializing_the_game" id="initializing_the_game">Initializing the Game</a></h2>
<div class="level2">

<p>

As usual, you initialize the game in the <code>simpleInitApp()</code> method.
</p>
<pre class="code java">    flyCam.<span class="me1">setMoveSpeed</span><span class="br0">&#40;</span><span class="nu0">100</span><span class="br0">&#41;</span>;
    setupKeys<span class="br0">&#40;</span><span class="br0">&#41;</span>;</pre>
<p>
You repurpose the default flyCam camera as first-person camera and set its speed. 
The auxiliary method <code>setupKeys()</code> configures key mappings–we will look at it later. 
</p>

</div>
<!-- SECTION "Initializing the Game" [8054-8399] -->
<h3><a name="the_physics-controlled_scene" id="the_physics-controlled_scene">The Physics-Controlled Scene</a></h3>
<div class="level3">

<p>

The first thing you do in every physics game is create a BulletAppState object. It gives you access to jME3&#039;s jBullet integration which handles physical forces and collisions.
</p>
<pre class="code java">    bulletAppState <span class="sy0">=</span> <span class="kw1">new</span> BulletAppState<span class="br0">&#40;</span><span class="br0">&#41;</span>;
    stateManager.<span class="me1">attach</span><span class="br0">&#40;</span>bulletAppState<span class="br0">&#41;</span>;</pre>
<p>
For the scene, you load the <code>sceneModel</code> from a zip file, and adjust the size. 
</p>
<pre class="code java">    assetManager.<span class="me1">registerLocator</span><span class="br0">&#40;</span><span class="st0">&quot;town.zip&quot;</span>, ZipLocator.<span class="kw1">class</span>.<span class="me1">getName</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
    sceneModel <span class="sy0">=</span> assetManager.<span class="me1">loadModel</span><span class="br0">&#40;</span><span class="st0">&quot;main.scene&quot;</span><span class="br0">&#41;</span>;
    sceneModel.<span class="me1">setLocalScale</span><span class="br0">&#40;</span>2f<span class="br0">&#41;</span>;</pre>
<p>
The file <code>town.zip</code> is included as a sample model in the JME3 sources – you can <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://jmonkeyengine.googlecode.com/svn/branches/jme3/town.zip"><param name="text" value="<html><u>download it here</u></html>"><param name="textColor" value="blue"></object>. (Optionally, use any OgreXML scene of your own.) For this sample, place the zip file in the application&#039;s top level directory (that is, next to src/, assets/, build.xml).
</p>
<pre class="code java">    CompoundCollisionShape sceneShape <span class="sy0">=</span> 
       CollisionShapeFactory.<span class="me1">createMeshCompoundShape</span><span class="br0">&#40;</span><span class="br0">&#40;</span>Node<span class="br0">&#41;</span> sceneModel<span class="br0">&#41;</span>;
    PhysicsNode landscape <span class="sy0">=</span> <span class="kw1">new</span> PhysicsNode<span class="br0">&#40;</span>sceneModel, sceneShape, 0<span class="br0">&#41;</span>;</pre>
<p>
To use collision detection, you want to turn the <code>sceneModel</code> Spatial into a <code>PhysicsNode</code>. A PhysicsNode takes three arguments: A Spatial, its Collision Shape, and its mass. 
</p>

<p>
JME3 offers a <code>CollisionShapeFactory</code> that precalculates a mesh-accurate collision shape for a Spatial. We choose to generate a <code>CompoundCollisionShape</code>, which has MeshCollisionShapes as its children. <strong>Note:</strong> This type of collision shape is optimal for immobile objects, such as terrain, houses, and whole shooter levels. 
</p>

<p>
You set the mass to zero since a scene is static and its mass irrevelant. 
</p>

<p>
<strong>Tip:</strong> Remember to always add a light source so you can see the scene.
</p>

</div>
<!-- SECTION "The Physics-Controlled Scene" [8400-10196] -->
<h3><a name="the_physics-controlled_player" id="the_physics-controlled_player">The Physics-Controlled Player</a></h3>
<div class="level3">

<p>

Next you set up collision detection for the player. 
</p>
<pre class="code java"><span class="kw1">new</span> CapsuleCollisionShape<span class="br0">&#40;</span>1.5f, 6f, <span class="nu0">1</span><span class="br0">&#41;</span></pre>
<p>
Again, you create a CollisionShape: This time we choose a CapsuleCollisionShape, a cylinder with a rounded top and bottom. <strong>Note:</strong> This shape is optimal for a person: It&#039;s tall and the roundness helps to get stuck less often on obstacles. 
</p>

<p>
Supply the CapsuleCollisionShape constructor with the desired size of the bounding capsule to fit the shape of your character. In this example the character is 2*1.5f units wide, and 6f units tall. 
</p>

<p>
The final integer argument specifies the orientation of the cylinder: 1 is the Y-axis, which fits an upright person. For many animals and vehicles you would use 0 or 2.
</p>
<pre class="code java">    player <span class="sy0">=</span> <span class="kw1">new</span> PhysicsCharacterNode<span class="br0">&#40;</span><span class="kw1">new</span> CapsuleCollisionShape<span class="br0">&#40;</span>1.5f, 6f, <span class="nu0">1</span><span class="br0">&#41;</span>, .05f<span class="br0">&#41;</span>;</pre>
<p>
Now you use the CollisionShape to create a <code>PhysicsCharacterNode</code> that represents the player. The last argument of the <code>PhysicsCharacterNode</code> constructor (here <code>.05f</code>) is the size of a step that the character should be able to surmount.
</p>
<pre class="code java">    player.<span class="me1">setJumpSpeed</span><span class="br0">&#40;</span><span class="nu0">20</span><span class="br0">&#41;</span>;
    player.<span class="me1">setFallSpeed</span><span class="br0">&#40;</span><span class="nu0">30</span><span class="br0">&#41;</span>;
    player.<span class="me1">setGravity</span><span class="br0">&#40;</span><span class="nu0">30</span><span class="br0">&#41;</span>;</pre>
<p>
Apart from step height and character size, the <code>PhysicsCharacterNode</code> lets you configure jumping, falling, and gravity speeds. Adjust the values to fit your game situation.
</p>
<pre class="code java">    player.<span class="me1">setLocalTranslation</span><span class="br0">&#40;</span><span class="kw1">new</span> Vector3f<span class="br0">&#40;</span>0, <span class="nu0">10</span>, 0<span class="br0">&#41;</span><span class="br0">&#41;</span>;</pre>
<p>
Finally we put the player in its starting position and update its state – pretty standard.
</p>

</div>
<!-- SECTION "The Physics-Controlled Player" [10197-11764] -->
<h3><a name="activating_the_physicsspace" id="activating_the_physicsspace">Activating the PhysicsSpace</a></h3>
<div class="level3">

<p>

As in every JME3 application, you must attach the scene and the player to the <code>rootNode</code> to make them appear in the game world.
</p>
<pre class="code java">    rootNode.<span class="me1">attachChild</span><span class="br0">&#40;</span>landscape<span class="br0">&#41;</span>;
    rootNode.<span class="me1">attachChild</span><span class="br0">&#40;</span>player<span class="br0">&#41;</span>;</pre>
<p>
Remember that for physical games, you must also add all solid objects (usually the characters and the scene) to the <code>PhysicsSpace</code>!
</p>
<pre class="code java">    bulletAppState.<span class="me1">getPhysicsSpace</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">add</span><span class="br0">&#40;</span>landscape<span class="br0">&#41;</span>;
    bulletAppState.<span class="me1">getPhysicsSpace</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">add</span><span class="br0">&#40;</span>player<span class="br0">&#41;</span>;</pre>
</div>
<!-- SECTION "Activating the PhysicsSpace" [11765-12285] -->
<h2><a name="navigation" id="navigation">Navigation</a></h2>
<div class="level2">

<p>

The default camera controller <code>cam</code> is a third-person camera. JME3 also offers a first-person controller, <code>flyCam</code>, which we use here to handle camera rotation. 
</p>

<p>
However we must redefine how walking is handled for physics-controlled objects: When you navigate a physical node, you do not specify a <em>target location</em>, but a <em>walk direction</em>. The physics space calculates how far the character can actually go in the desired direction – or whether it will be stoped by an obstacle.
</p>

<p>
This is why we must re-define the flyCam&#039;s navigational key mappings to use <code>setWalkDirection()</code> instead of <code>setLocalTranslation()</code>. Here are the steps:
</p>

</div>
<!-- SECTION "Navigation" [12286-12958] -->
<h3><a name="inputmanager" id="inputmanager">1. inputManager</a></h3>
<div class="level3">

<p>

Configure the familiar WASD inputs for walking, and Space for jumping. 
</p>
<pre class="code java">    inputManager.<span class="me1">addMapping</span><span class="br0">&#40;</span><span class="st0">&quot;Lefts&quot;</span>,  <span class="kw1">new</span> KeyTrigger<span class="br0">&#40;</span>KeyInput.<span class="me1">KEY_A</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
    inputManager.<span class="me1">addMapping</span><span class="br0">&#40;</span><span class="st0">&quot;Rights&quot;</span>, <span class="kw1">new</span> KeyTrigger<span class="br0">&#40;</span>KeyInput.<span class="me1">KEY_D</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
    inputManager.<span class="me1">addMapping</span><span class="br0">&#40;</span><span class="st0">&quot;Ups&quot;</span>,    <span class="kw1">new</span> KeyTrigger<span class="br0">&#40;</span>KeyInput.<span class="me1">KEY_W</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
    inputManager.<span class="me1">addMapping</span><span class="br0">&#40;</span><span class="st0">&quot;Downs&quot;</span>,  <span class="kw1">new</span> KeyTrigger<span class="br0">&#40;</span>KeyInput.<span class="me1">KEY_S</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
    inputManager.<span class="me1">addMapping</span><span class="br0">&#40;</span><span class="st0">&quot;Jumps&quot;</span>,  <span class="kw1">new</span> KeyTrigger<span class="br0">&#40;</span>KeyInput.<span class="me1">KEY_SPACE</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
    inputManager.<span class="me1">addListener</span><span class="br0">&#40;</span><span class="kw1">this</span>, <span class="st0">&quot;Lefts&quot;</span><span class="br0">&#41;</span>;
    inputManager.<span class="me1">addListener</span><span class="br0">&#40;</span><span class="kw1">this</span>, <span class="st0">&quot;Rights&quot;</span><span class="br0">&#41;</span>;
    inputManager.<span class="me1">addListener</span><span class="br0">&#40;</span><span class="kw1">this</span>, <span class="st0">&quot;Ups&quot;</span><span class="br0">&#41;</span>;
    inputManager.<span class="me1">addListener</span><span class="br0">&#40;</span><span class="kw1">this</span>, <span class="st0">&quot;Downs&quot;</span><span class="br0">&#41;</span>;
    inputManager.<span class="me1">addListener</span><span class="br0">&#40;</span><span class="kw1">this</span>, <span class="st0">&quot;Jumps&quot;</span><span class="br0">&#41;</span>;</pre>
<p>
In the code sample above, this block of code was moved into an auxiliary method <code>setupKeys()</code> that is called from <code>simpleInitApp()</code>–this is just to keep the code more readable.
</p>

</div>
<!-- SECTION "1. inputManager" [12959-13845] -->
<h3><a name="onaction" id="onaction">2. onAction()</a></h3>
<div class="level3">

<p>

Remember that we declared this class an <code>ActionListener</code> so we could customize the flyCam. The <code>ActionListener</code> interface requires us to implement the <code>onAction()</code> method: You re-define the actions triggered by navigation key presses to work with physics.
</p>
<pre class="code java">  <span class="kw1">public</span> <span class="kw4">void</span> onAction<span class="br0">&#40;</span><object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://www.google.com/search?hl=en&amp;q=allinurl%3Astring+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky"><param name="text" value="<html><u></u></html>"><param name="textColor" value="blue"></object> binding, <span class="kw4">boolean</span> value, <span class="kw4">float</span> tpf<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>binding.<span class="me1">equals</span><span class="br0">&#40;</span><span class="st0">&quot;Lefts&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span> left <span class="sy0">=</span> <span class="kw2">true</span>; <span class="br0">&#125;</span>  <span class="kw1">else</span> <span class="br0">&#123;</span> left <span class="sy0">=</span> <span class="kw2">false</span>; <span class="br0">&#125;</span>
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>binding.<span class="me1">equals</span><span class="br0">&#40;</span><span class="st0">&quot;Rights&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span> right <span class="sy0">=</span> <span class="kw2">true</span>; <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span> right <span class="sy0">=</span> <span class="kw2">false</span>; <span class="br0">&#125;</span>
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>binding.<span class="me1">equals</span><span class="br0">&#40;</span><span class="st0">&quot;Ups&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span> up <span class="sy0">=</span> <span class="kw2">true</span>; <span class="br0">&#125;</span>    <span class="kw1">else</span> <span class="br0">&#123;</span> up <span class="sy0">=</span> <span class="kw2">false</span>; <span class="br0">&#125;</span>
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>binding.<span class="me1">equals</span><span class="br0">&#40;</span><span class="st0">&quot;Downs&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span> down <span class="sy0">=</span> <span class="kw2">true</span>; <span class="br0">&#125;</span>  <span class="kw1">else</span> <span class="br0">&#123;</span> down <span class="sy0">=</span> <span class="kw2">false</span>; <span class="br0">&#125;</span>
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>binding.<span class="me1">equals</span><span class="br0">&#40;</span><span class="st0">&quot;Jumps&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      player.<span class="me1">jump</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
  <span class="br0">&#125;</span></pre>
<p>
Every time the user presses one of the WASD keys, you keep track of the direction the user wants to go – by storing this info in four directional Booleans. We will use them soon.
</p>

<p>
Note that no actual walking happens here – not yet! 
</p>

<p>
The only movement that you do not have to implement yourself is the jumping action. The call <code>player.jump()</code> is a special method that handles a correct jumping motion for your <code>PhysicsCharacterNode</code>.
</p>

</div>
<!-- SECTION "2. onAction()" [13846-15126] -->
<h3><a name="setwalkdirection" id="setwalkdirection">3. setWalkDirection()</a></h3>
<div class="level3">

<p>

In <code>onAction()</code> you have determined in which direction the user wants to go in terms of “forward” or “left”. 
Now you need poll the current rotation of the camera to find to which vectors “forward” and “left” correspond in the coordinate system.
This last and most important code snippet goes into the main event loop, <code>simpleUpdate()</code>. 
</p>
<pre class="code java">    Vector3f camDir <span class="sy0">=</span> cam.<span class="me1">getDirection</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">clone</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">multLocal</span><span class="br0">&#40;</span>0.6f<span class="br0">&#41;</span>;
    Vector3f camLeft <span class="sy0">=</span> cam.<span class="me1">getLeft</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">clone</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">multLocal</span><span class="br0">&#40;</span>0.4f<span class="br0">&#41;</span>;
    walkDirection.<span class="me1">set</span><span class="br0">&#40;</span>0, 0, 0<span class="br0">&#41;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>left<span class="br0">&#41;</span>  <span class="br0">&#123;</span> walkDirection.<span class="me1">addLocal</span><span class="br0">&#40;</span>camLeft<span class="br0">&#41;</span>; <span class="br0">&#125;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>right<span class="br0">&#41;</span> <span class="br0">&#123;</span> walkDirection.<span class="me1">addLocal</span><span class="br0">&#40;</span>camLeft.<span class="me1">negate</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>up<span class="br0">&#41;</span>    <span class="br0">&#123;</span> walkDirection.<span class="me1">addLocal</span><span class="br0">&#40;</span>camDir<span class="br0">&#41;</span>; <span class="br0">&#125;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>down<span class="br0">&#41;</span>  <span class="br0">&#123;</span> walkDirection.<span class="me1">addLocal</span><span class="br0">&#40;</span>camDir.<span class="me1">negate</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span></pre>
<p>
Reset the variable <code>walkDirection</code> to zero. Then add to it all latest motion vectors that you polled from the camera. It is posible for a character to move forward and to the left simultaneously.
</p>
<pre class="code java">player.<span class="me1">setWalkDirection</span><span class="br0">&#40;</span>walkDirection<span class="br0">&#41;</span>;</pre>
<p>
This one line does the “walking” magic: Always use <code>setWalkDirection()</code> to make a physics-controlled object move, and the <code>SimpleBulletApplication</code> automatically handles collision detection for you! 
</p>

<p>
<strong>Important:</strong> Do not use <code>setLocalTranslation()</code> to walk the player around – because you may get it stuck by overlapping with another physical object. You may put the player in a start position with <code>setLocalTranslation()</code> if you make sure to place it a bit above the floor and away from obstacles.
</p>

<p>
Lastly, do not forget to make the first-person camera object move along with the physics-controlled player node: 
</p>
<pre class="code java">cam.<span class="me1">setLocation</span><span class="br0">&#40;</span>player.<span class="me1">getLocalTranslation</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;</pre>
<p>
That&#039;s it!
</p>

</div>
<!-- SECTION "3. setWalkDirection()" [15127-16870] -->
<h2><a name="conclusion" id="conclusion">Conclusion</a></h2>
<div class="level2">

<p>

You have learned how to load a “solid” physical scene model and walk around in it with a first-person perspective. 
You had JME3 calculate the CollisionShapes, and you represented collidables as PhysicsNodes that you registered to the Physics Space. 
You also made certain to use <code>player.setWalkDirection(walkDirection)</code> to move physical characters around.
</p>

<p>
To learn more about different ways of loading models and scene have a look at <a href="/com/jme3/gde/core/docs/jme3/beginner/hello_asset.html" class="wikilink1" title="jme3:beginner:hello_asset">Hello Asset</a>,<a href="/com/jme3/gde/core/docs/jme3/jmonkeyplatform/scene_explorer.html" class="wikilink1" title="jme3:jmonkeyplatform:scene_explorer">Scene Explorer</a> and <a href="/com/jme3/gde/core/docs/jme3/jmonkeyplatform/scene_composer.html" class="wikilink1" title="jme3:jmonkeyplatform:scene_composer">Scene Composer</a>
</p>

<p>
There are also other possible solutions for this task that do not require physics. 
Have a look at <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://code.google.com/p/jmonkeyengine/source/browse/branches/jme3/src/test/jme3test/collision/TestSimpleCollision.java?r=5192&amp;spec=svn5192"><param name="text" value="<html><u>jme3test.collision.TestSimpleCollision.java</u></html>"><param name="textColor" value="blue"></object> (and SphereMotionAllowedListener.java).
To learn more about complex physics scenes where several mobile physical objects bump into each other, read <a href="/com/jme3/gde/core/docs/jme3/beginner/hello_physics.html" class="wikilink1" title="jme3:beginner:hello_physics">Hello Physics</a>.
</p>

<p>
Do you want to hear your player say “ouch!” when he bumps into a wall? Continue with learning <a href="/com/jme3/gde/core/docs/jme3/beginner/hello_audio.html" class="wikilink1" title="jme3:beginner:hello_audio">how to add sound</a> to your game.

</p>

</div>
<!-- SECTION "Conclusion" [16871-] -->
<p><em><a href="http://jmonkeyengine.org/wiki/doku.php/jme3:beginner:hello_collision?do=export_xhtmlbody">view online version</a></em></p>