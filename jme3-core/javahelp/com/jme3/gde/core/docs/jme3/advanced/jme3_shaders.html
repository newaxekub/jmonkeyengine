


<h1><a name="jme3_and_shaders" id="jme3_and_shaders">JME3 and Shaders</a></h1>
<div class="level1">

<p>
<br/>


</p>

</div>
<!-- SECTION "JME3 and Shaders" [1-36] -->
<h1><a name="shaders_basics" id="shaders_basics">Shaders Basics</a></h1>
<div class="level1">

<p>
Shaders are sets of instructions that are executed on the GPU. They are used to take advantage of hardware acceleration available on the GPU for rendering purposes.<br/>

This paper only covers Vertex and Fragment shaders because they are the only ones supported by JME3 for the moment. But be aware that there are some other types of shaders (geometry, tessellation,…).<br/>

There are multiple frequently used languages that you may encounter to code shaders but as JME3 is based on OpenGL, shaders in JME use GLSL and any example in this paper will be written in GLSL.<br/>

<br/>


</p>

</div>
<!-- SECTION "Shaders Basics" [37-634] -->
<h3><a name="how_does_it_work" id="how_does_it_work">How Does it work?</a></h3>
<div class="level3">

<p>
To keep it Simple: The Vertex shader is executed once for each vertex in the view, then the Fragment shader (also called the Pixel shader) is executed once for each pixel on the screen.<br/>

The main purpose of the Vertex shader is to compute the screen coordinate of a vertex (where this vertex will be displayed on screen) while the main purpose of the Fragment shader is to compute the color of a pixel.<br/>

This is a very simplified graphic to describe the call stack: <br/>

<img src="/wiki/lib/exe/fetch.php"><br/>

The main program sends mesh data to the vertex shader (vertex position in object space, normals, tangents, etc..). The vertex shader computes the screen position of the vertex and sends it to the Fragment shader. The fragment shader computes the color, and the result is displayed on screen or in a texture.
<br/>


</p>

</div>
<!-- SECTION "How Does it work?" [635-1523] -->
<h3><a name="variables_scope" id="variables_scope">Variables scope</a></h3>
<div class="level3">

<p>
There are different types of scope for variables in a shader : 
</p>
<ul>
<li class="level1"><div class="li"> uniform : User defined variables that are passed by the main program to the vertex and fragment shader, these variables are global for a given execution of a shader.</div>
</li>
<li class="level1"><div class="li"> attribute : Per-vertex variables passed by the engine to the shader, like position, normal, etc (Mesh data in the graphic)</div>
</li>
<li class="level1"><div class="li"> varrying : Variables passed from the vertex shader to the fragment shader.</div>
</li>
</ul>

<p>

There is a large panel of variable types to be used, for more information about it I recommend reading the GLSL specification <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://www.opengl.org/registry/doc/GLSLangSpec.Full.1.20.8.pdf"><param name="text" value="<html><u>here</u></html>"><param name="textColor" value="blue"></object>.<br/>

<br/>

</p>

</div>
<!-- SECTION "Variables scope" [1524-2193] -->
<h3><a name="spaces_and_matrices" id="spaces_and_matrices">Spaces and Matrices</a></h3>
<div class="level3">

<p>
To understand the coming example you must know about the different spaces in 3D computer graphics, and the matrices used to translate coordinate from one space to another.<br/>

<img src="/wiki/lib/exe/fetch.php"><br/>

The engine passes the object space coordinates to the vertex shader. We need to compute its position in projection space. To do that we transform the object space position by the WorldViewProjectionMatrix which is a combination of the World, View, Projection matrices (who would have guessed?).<br/>

<br/>


</p>

</div>
<!-- SECTION "Spaces and Matrices" [2194-2774] -->
<h3><a name="simple_example_rendering_a_solid_color_on_an_object" id="simple_example_rendering_a_solid_color_on_an_object">Simple example : rendering a solid color on an object</a></h3>
<div class="level3">

<p>
Here is the simplest application to shaders, rendering a solid color.<br/>

Vertex Shader : <br/>


</p>
<pre class="code java"><span class="co1">//the global uniform World view projection matrix </span>
<span class="co1">//(more on global uniforms below)</span>
uniform mat4 g_WorldViewProjectionMatrix;
<span class="co1">//The attribute inPosition is the Object space position of the vertex</span>
attribute vec3 inPosition;
&nbsp;
<span class="kw4">void</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#123;</span>
    <span class="co1">//Transformation of the object space coordinate to projection space</span>
    <span class="co1">//coordinates.</span>
    <span class="co1">//- gl_Position is the standard GLSL variable holding projection space</span>
    <span class="co1">//position. It must be filled in the vertex shader</span>
    <span class="co1">//- To convert position we multiply the worldViewProjectionMatrix by</span>
    <span class="co1">//by the position vector. </span>
    <span class="co1">//The multiplication must be done in this order.</span>
    gl_Position <span class="sy0">=</span> g_WorldViewProjectionMatrix <span class="sy0">*</span> vec4<span class="br0">&#40;</span>inPosition, <span class="nu0">1.0</span><span class="br0">&#41;</span>;
<span class="br0">&#125;</span></pre>
<p>
Fragment Shader : <br/>


</p>
<pre class="code java"><span class="kw4">void</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#123;</span>
    <span class="co1">//returning the color of the pixel (here solid blue)</span>
    <span class="co1">//- gl_FragColor is the standard GLSL variable that holds the pixel</span>
    <span class="co1">//color. It must be filled in the Fragment Shader.</span>
    gl_FragColor <span class="sy0">=</span> vec4<span class="br0">&#40;</span><span class="nu0">0.0</span>, <span class="nu0">0.0</span>, <span class="nu0">1.0</span>, <span class="nu0">1.0</span><span class="br0">&#41;</span>;
<span class="br0">&#125;</span></pre>
<p>

For example applying this shader to a sphere would render a solid blue sphere on screen.<br/>

<br/>

</p>

</div>
<!-- SECTION "Simple example : rendering a solid color on an object" [2775-4017] -->
<h1><a name="how_to_use_shaders_in_jme3" id="how_to_use_shaders_in_jme3">How to use shaders in JME3</a></h1>
<div class="level1">

<p>
You probably heard that JME3 is “shader oriented”, but what does that mean?<br/>

Usually to use shaders you must create what is called a program. This program specify the vertex shader and the fragment shader to use.<br/>

JME3 encloses this in the material system. Every material in JME3 uses shaders.<br/>

For example let’s have a look at the SolidColor.j3md file : <br/>


</p>
<pre class="code java">MaterialDef Solid <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://www.google.com/search?hl=en&amp;q=allinurl%3Acolor+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky"><param name="text" value="<html><u></u></html>"><param name="textColor" value="blue"></object> <span class="br0">&#123;</span>
    <span class="co1">//This is the complete list of user defined uniforms to be used in the</span>
    <span class="co1">//shaders</span>
    MaterialParameters <span class="br0">&#123;</span>
        Vector4 m_Color
    <span class="br0">&#125;</span>
&nbsp;
    Technique <span class="br0">&#123;</span>
        <span class="co1">//This is where the vertex and fragment shader files are</span>
        <span class="co1">//specified</span>
        VertexShader GLSL100<span class="sy0">:</span>   Common<span class="sy0">/</span>MatDefs<span class="sy0">/</span>Misc<span class="sy0">/</span>SolidColor.<span class="me1">vert</span>
        FragmentShader GLSL100<span class="sy0">:</span> Common<span class="sy0">/</span>MatDefs<span class="sy0">/</span>Misc<span class="sy0">/</span>SolidColor.<span class="me1">frag</span>
&nbsp;
        <span class="co1">//This is where you specify which global uniform you need for your</span>
        <span class="co1">//shaders</span>
        WorldParameters <span class="br0">&#123;</span>
            WorldViewProjectionMatrix
        <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
    Technique FixedFunc <span class="br0">&#123;</span>
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>

For more information on JME3 material system, i suggest you read this <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://jmonkeyengine.org/groups/development-discussion-jme3/forum/topic/jmonkeyengine3-material-system-full-explanation"><param name="text" value="<html><u>topic</u></html>"><param name="textColor" value="blue"></object>.<br/>

<br/>


</p>

</div>
<!-- SECTION "How to use shaders in JME3" [4018-5265] -->
<h3><a name="jme3_global_uniforms" id="jme3_global_uniforms">JME3 Global uniforms</a></h3>
<div class="level3">

<p>
JME3 can expose pre-computed global uniforms to your shaders. You must specify the one that are required for your shader in the WorldParameters section of the material definition file (.j3md).<br/>

Note that in the shader the uniform names will be prefixed by a “g_”.<br/>

In the example above, WorldViewProjectionMatrix is declared as uniform mat4 g_WorldViewProjectionMatrix in the shader.<br/>

The complete list of global uniforms that can be used in JME3 can be found <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://code.google.com/p/jmonkeyengine/source/browse/branches/jme3/src/core/com/jme3/shader/UniformBinding.java"><param name="text" value="<html><u>here</u></html>"><param name="textColor" value="blue"></object>.<br/>

<br/>


</p>

</div>
<!-- SECTION "JME3 Global uniforms" [5266-5888] -->
<h3><a name="jme3_attributes" id="jme3_attributes">JME3 attributes</a></h3>
<div class="level3">

<p>
Those are different attributes that are always passed to your shader.<br/>

you can find a complete list of those attribute in the Type enum of the VertexBuffer <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://code.google.com/p/jmonkeyengine/source/browse/branches/jme3/src/core/com/jme3/scene/VertexBuffer.java"><param name="text" value="<html><u>here</u></html>"><param name="textColor" value="blue"></object>.<br/>

Note that in the shader the attributes names will be prefixed by a “in”.<br/>

<br/>


</p>

</div>
<!-- SECTION "JME3 attributes" [5889-6272] -->
<h3><a name="step_by_step" id="step_by_step">Step by step</a></h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> Create a vertex shader (.vert) file</div>
</li>
<li class="level1"><div class="li"> Create a fragment shader (.frag) file</div>
</li>
<li class="level1"><div class="li"> Create a material definition (j3md) file specifying the user defined uniforms, path to the shaders and the global uniforms to use</div>
</li>
<li class="level1"><div class="li"> In your initSimpleApplication, create a material using this definition, apply it to a geometry </div>
</li>
<li class="level1"><div class="li"> That’s it!!</div>
</li>
</ul>
<pre class="code java">    <span class="co1">// A cube </span>
    <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://www.google.com/search?hl=en&amp;q=allinurl%3Abox+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky"><param name="text" value="<html><u></u></html>"><param name="textColor" value="blue"></object><span class="br0">&#40;</span>Vector3f.<span class="me1">ZERO</span>, 1f,1f,1f<span class="br0">&#41;</span>;
    Geometry cube <span class="sy0">=</span> <span class="kw1">new</span> Geometry<span class="br0">&#40;</span><span class="st0">&quot;box&quot;</span>, box<span class="br0">&#41;</span>;
    Material mat <span class="sy0">=</span> <span class="kw1">new</span> Material<span class="br0">&#40;</span>assetManager,<span class="st0">&quot;Path/To/My/materialDef.j3md&quot;</span><span class="br0">&#41;</span>;
    cube.<span class="me1">setMaterial</span><span class="br0">&#40;</span>mat<span class="br0">&#41;</span>;
    rootNode.<span class="me1">attachChild</span><span class="br0">&#40;</span>cube<span class="br0">&#41;</span>;</pre>
<p>

<br/>


</p>

</div>
<!-- SECTION "Step by step" [6273-6894] -->
<h3><a name="jme3_and_opengl_3_4_compatibility" id="jme3_and_opengl_3_4_compatibility">JME3 and OpenGL 3 &amp; 4 compatibility</a></h3>
<div class="level3">

<p>
GLSL 1.0 to 1.2 comes with build in attributes and uniforms (ie, gl_Vertex, gl_ModelViewMatrix, etc…).<br/>
 Those attributes are deprecated since GLSL 1.3 (opengl 3), hence JME3 global uniforms and attributes. Here is a list of deprecated attributes and their equivalent in JME3<br/>

</p>
<table class="inline">
	<tr class="row0">
		<th class="col0">GLSL 1.2 attributes</th><th class="col1">JME3 equivalent</th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign">gl_Vertex	</td><td class="col1">inPosition</td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign">gl_Normal	</td><td class="col1">inNormal</td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign">gl_Color	</td><td class="col1">inColor</td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign">gl_MultiTexCoord0	</td><td class="col1">inTexCoord</td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign">gl_ModelViewMatrix	</td><td class="col1">g_WorldViewMatrix</td>
	</tr>
	<tr class="row6">
		<td class="col0 leftalign">gl_ProjectionMatrix	</td><td class="col1">g_ProjectionMatrix</td>
	</tr>
	<tr class="row7">
		<td class="col0 leftalign">gl_ModelViewProjectionMatrix	</td><td class="col1">g_WorldViewMatrix</td>
	</tr>
	<tr class="row8">
		<td class="col0 leftalign">gl_NormalMatrix	</td><td class="col1">g_NormalMatrix</td>
	</tr>
</table>

</div>
<!-- SECTION "JME3 and OpenGL 3 & 4 compatibility" [6895-] -->
<p><em><a href="http://jmonkeyengine.org/wiki/doku.php/jme3:advanced:jme3_shaders?do=export_xhtmlbody">view online version</a></em></p>