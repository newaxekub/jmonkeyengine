


<h1><a name="physicsgravity_collisions_forces" id="physicsgravity_collisions_forces">Physics: Gravity, Collisions, Forces</a></h1>
<div class="level1">

<p>

The jMonkeyEngine3 has built-in support for <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://jbullet.advel.cz"><param name="text" value="<html><u>jBullet physics</u></html>"><param name="textColor" value="blue"></object> via the <code>com.jme3.bullet</code> package.
Game Physics are used in applications that simulate mass/gravity, collisions, and friction. Think of pool billiard or car racing simulations.
</p>

</div>
<!-- SECTION "Physics: Gravity, Collisions, Forces" [1-320] -->
<h2><a name="sample_code" id="sample_code">Sample Code</a></h2>
<div class="level2">

<p>

Full code samples are here:

</p>
<ul>
<li class="level1"><div class="li"> <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://code.google.com/p/jmonkeyengine/source/browse/branches/jme3/src/test/jme3test/bullet/TestBrickWall.java"><param name="text" value="<html><u>TestBrickWall.java</u></html>"><param name="textColor" value="blue"></object></div>
</li>
<li class="level1"><div class="li"> <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://code.google.com/p/jmonkeyengine/source/browse/branches/jme3/src/test/jme3test/bullet/TestQ3.java"><param name="text" value="<html><u>TestQ3.java</u></html>"><param name="textColor" value="blue"></object></div>
</li>
<li class="level1"><div class="li"> <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://code.google.com/p/jmonkeyengine/source/browse/branches/jme3/src/test/jme3test/bullet/TestSimplePhysics.java"><param name="text" value="<html><u>TestSimplePhysics.java</u></html>"><param name="textColor" value="blue"></object></div>
</li>
<li class="level1"><div class="li"> <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://code.google.com/p/jmonkeyengine/source/browse/branches/jme3/src/test/jme3test/bullet/TestWalkingCharacter.java"><param name="text" value="<html><u>TestWalkingCharacter.java</u></html>"><param name="textColor" value="blue"></object></div>
</li>
</ul>

</div>
<!-- SECTION "Sample Code" [321-935] -->
<h2><a name="physics_application" id="physics_application">Physics Application</a></h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Extend <code>com.jme3.app.SimpleApplication</code> and create a BulletAppState to initialize a new physical game. <pre class="code java">  <span class="kw1">private</span> BulletAppState bulletAppState; 
  ...
  <span class="kw1">public</span> <span class="kw4">void</span> simpleInitApp<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    bulletAppState <span class="sy0">=</span> <span class="kw1">new</span> BulletAppState<span class="br0">&#40;</span><span class="br0">&#41;</span>;
    stateManager.<span class="me1">attach</span><span class="br0">&#40;</span>bulletAppState<span class="br0">&#41;</span>;
    ...</pre></div>
<ul>
<li class="level2"><div class="li"> Create a Physics Node with collision shape and mass.</div>
</li>
<li class="level2"><div class="li"> Add the Physics Node to the <code>bulletAppState.getPhysicsSpace()</code> object.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Implement the <code>PhysicsCollisionListener</code> interface to respond to <code>PhysicsCollisionEvent</code>s.</div>
</li>
</ul>

</div>
<!-- SECTION "Physics Application" [936-1504] -->
<h3><a name="collision_shapes" id="collision_shapes">Collision Shapes</a></h3>
<div class="level3">

<p>

Before you can create a Physics Node, you must create a CollisionShape from the <code>com.jme3.bullet.collision.shapes</code> package. 
</p>

<p>
The collision shape is a simplified shape for which physics are easier to calculate than for the real shape of the model. This speeds up the simulation greatly.

</p>
<table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Shape                     </th><th class="col1"> Purpose </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> BoxCollisionShape         </td><td class="col1"> Box shaped objects such as bricks, crates, simple obstacles. Does not roll. </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> SphereCollisionShape      </td><td class="col1"> Spherical objects such as balls. Can roll. </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> CylinderCollisionShape    </td><td class="col1"> Tube-shaped pillars, disc-shaped wheels. Can roll on one side. </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> CapsuleCollisionShape     </td><td class="col1"> A compound of a cylinder plus two spheres at the top and bottom. Rotated upright, this shape is optimal for character nodes: A cylinder-shaped body does not get stuck at corners and vertical obstacles; the rounded top and bottom do not get stuck on stair steps and ground obstacles. </td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign"> CompoundCollisionShape    </td><td class="col1"> A CompoundCollisionShape allows combining box/sphere/cylinder shapes to form one more sophisticated shape. </td>
	</tr>
	<tr class="row6">
		<td class="col0 leftalign"> MeshCollisionShape        </td><td class="col1"> A freeform mesh-accurate shape that wraps itself around a mesh. <br/>
 <strong>Limitations:</strong> Only non-mesh collision shapes (sphere, box, cylinder, compound) can collide with mesh-accurate collision shapes, so you can use the mesh-accurate ones only for static obstacles (e.g. a complex game level). </td>
	</tr>
	<tr class="row7">
		<td class="col0"> HeightFieldCollisionShape </td><td class="col1"> For static terrains, this shape is much faster than a mesh shape.</td>
	</tr>
	<tr class="row8">
		<td class="col0 leftalign"> GImpactCollisionShape     </td><td class="col1"> Can be used for moving mesh collision shapes (CPU intense! Use of basic shapes combined as CompoundCollisionShapes is preferred!) Uses <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://gimpact.sourceforge.net/"><param name="text" value="<html><u>http://gimpact.sourceforge.net/</u></html>"><param name="textColor" value="blue"></object>. </td>
	</tr>
</table>

<p>

Pick the right shape for the mesh for what you want to achieve: If you give a box a sphere collision shape, it will roll… If you give a ball a box collision shape, it will sit on a slope…!
</p>

</div>
<!-- SECTION "Collision Shapes" [1505-3413] -->
<h3><a name="collision_shape_code_samples" id="collision_shape_code_samples">Collision Shape Code Samples</a></h3>
<div class="level3">

<p>

MeshCompoundShape and MeshCollisionShape are both mesh-accurate and are meant for immobile scene objects, such as terrains, buildings, or whole shooter levels. Limitation: Only collisions of non-mesh-accurate shapes (sphere, box, etc) shapes can be detected on mesh-accurate shapes.
</p>
<pre class="code java">CompoundCollisionShape myComplexShape <span class="sy0">=</span> 
    CollisionShapeFactory.<span class="me1">createMeshCompoundShape</span><span class="br0">&#40;</span><span class="br0">&#40;</span>Node<span class="br0">&#41;</span> myComplexGeometry <span class="br0">&#41;</span>;</pre>
<p>
An optimized HeightfieldCollisionShape for a terrain:
</p>
<pre class="code java">TerrainPhysicsShapeFactory factory <span class="sy0">=</span> <span class="kw1">new</span> TerrainPhysicsShapeFactory<span class="br0">&#40;</span><span class="br0">&#41;</span>;
terrainPhysicsNode <span class="sy0">=</span> factory.<span class="me1">createPhysicsMesh</span><span class="br0">&#40;</span>terrain<span class="br0">&#41;</span>;</pre>
<p>
An angular, non-mesh-accurate compound shape:
</p>
<pre class="code java">CompoundCollisionShape boxShape <span class="sy0">=</span> 
    CollisionShapeFactory.<span class="me1">createBoxCompoundShape</span><span class="br0">&#40;</span><span class="br0">&#40;</span>Node<span class="br0">&#41;</span> someBox<span class="br0">&#41;</span>;</pre>
<p>
SphereCollisionShape, BoxCollisionShape, CapsuleCollisionShape are also not mesh-accurate, but have better performance. Collisions between them and any other shape can be detected.
</p>
<pre class="code java">BoxCollisionShape boxShape <span class="sy0">=</span> 
    <span class="kw1">new</span> BoxCollisionShape<span class="br0">&#40;</span><span class="kw1">new</span> Vector3f<span class="br0">&#40;</span>1f,2f,3f<span class="br0">&#41;</span><span class="br0">&#41;</span>, 1.5f<span class="br0">&#41;</span></pre><pre class="code java">CapsuleCollisionShape capsuleShape <span class="sy0">=</span> 
    <span class="kw1">new</span> CapsuleCollisionShape<span class="br0">&#40;</span>1f,2f<span class="br0">&#41;</span>;</pre>
</div>
<!-- SECTION "Collision Shape Code Samples" [3414-4628] -->
<h2><a name="physics_nodes" id="physics_nodes">Physics Nodes</a></h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Use <code>com.jme3.bullet.nodes.PhysicsNode</code> for physical parts of the scene, projectiles, and obstacles – things that are freely affected by physical forcs, be it by collision or by falling.</div>
</li>
<li class="level1"><div class="li"> Use <code>com.jme3.bullet.nodes.PhysicsCharacterNode</code> for characters (persons, animals) that stand upright, orthogonally to the X/Z plane. When directional forces are applied to this type of node, it does not tip over (like a physical object would), but it moves in a stable manner (like a walking character would).</div>
</li>
<li class="level1"><div class="li"> Use <code>PhysicsVehicleNode</code> and <code>PhysicsVehicleWheel</code> to create <a href="/com/jme3/gde/core/docs/jme3/advanced/vehicles.html" class="wikilink1" title="jme3:advanced:vehicles">Vehicles</a>.</div>
</li>
</ul>

</div>
<!-- SECTION "Physics Nodes" [4629-5265] -->
<h3><a name="physics_nodes_code_samples" id="physics_nodes_code_samples">Physics Nodes Code Samples</a></h3>
<div class="level3">

<p>

The standard PhysicsNode constructors expect a Geometry, a Collision Shape, and a mass.
</p>
<pre class="code java">PhysicsNode myThing<span class="sy0">=</span><span class="kw1">new</span> PhysicsNode<span class="br0">&#40;</span> thingGeo , thingShape , 1f<span class="br0">&#41;</span>;</pre>
<p>
The second PhysicsNode constructor only expects a collision shape and mass. To make this physical object visible in the scene, you must attach a Node with Geometric properties (e.g. a model) to the physical node:
</p>
<pre class="code java">PhysicsCharacterNode character <span class="sy0">=</span> <span class="kw1">new</span> PhysicsCharacterNode<span class="br0">&#40;</span>capsuleShape, 0.01f<span class="br0">&#41;</span>;
Node model <span class="sy0">=</span> <span class="br0">&#40;</span>Node<span class="br0">&#41;</span> assetManager.<span class="me1">loadModel</span><span class="br0">&#40;</span><span class="st0">&quot;Models/myCharacterModel.mesh.xml&quot;</span><span class="br0">&#41;</span>;
character.<span class="me1">attachChild</span><span class="br0">&#40;</span>model<span class="br0">&#41;</span>;      <span class="co1">// making the physical node visible </span>
bulletAppState.<span class="me1">getPhysicsSpace</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">add</span><span class="br0">&#40;</span>character<span class="br0">&#41;</span>;  <span class="co1">// making the PhysicsNode physical</span>
rootNode.<span class="me1">attachChild</span><span class="br0">&#40;</span>character<span class="br0">&#41;</span>;   <span class="co1">// making the whole thing appear in the scene</span></pre>
</div>
<!-- SECTION "Physics Nodes Code Samples" [5266-6112] -->
<h2><a name="physics_space" id="physics_space">Physics Space</a></h2>
<div class="level2">

<p>

The Physics Space is an object in BulletAppState that is like a rootNode for physical objects.
</p>
<ol>
<li class="level1"><div class="li"> First specify parameters such as gravity and accuracy.<pre class="code java">bulletAppState.<span class="me1">getPhysicsSpace</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">setGravity</span><span class="br0">&#40;</span><span class="kw1">new</span> Vector3f<span class="br0">&#40;</span>0f,<span class="sy0">-</span>1f,0f<span class="br0">&#41;</span><span class="br0">&#41;</span>;
bulletAppState.<span class="me1">getPhysicsSpace</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">setAccuracy</span><span class="br0">&#40;</span>0.005f<span class="br0">&#41;</span>;</pre></div>
</li>
<li class="level1"><div class="li"> All physics nodes muss be added to the Physics space.<pre class="code java">bulletAppState.<span class="me1">getPhysicsSpace</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">add</span><span class="br0">&#40;</span>myPhysicsNode<span class="br0">&#41;</span>; ...</pre></div>
</li>
<li class="level1"><div class="li"> All physics nodes must be attached to the rootNode<pre class="code java">rootNode.<span class="me1">attachChild</span><span class="br0">&#40;</span>myPhysicsNode<span class="br0">&#41;</span>; ...</pre></div>
</li>
<li class="level1"><div class="li"> Remove nodes from the scene like this: <pre class="code java">bulletAppState.<span class="me1">getPhysicsSpace</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">remove</span><span class="br0">&#40;</span>myPhysicsNode<span class="br0">&#41;</span>; 
physicalNode.<span class="me1">removeFromParent</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;</pre></div>
</li>
</ol>

</div>
<!-- SECTION "Physics Space" [6113-6831] -->
<h2><a name="properties_of_physical_objects" id="properties_of_physical_objects">Properties of Physical Objects</a></h2>
<div class="level2">

<p>

On a PhysicsNode, you can set the following physical properties.

</p>
<table class="inline">
	<tr class="row0">
		<th class="col0"> PhysicsNode Method </th><th class="col1"> Property </th>
	</tr>
	<tr class="row1">
		<td class="col0"> setFriction(1f) </td><td class="col1"> Friction. </td>
	</tr>
	<tr class="row2">
		<td class="col0"> setMass(1f) </td><td class="col1"> Dynamic objects have masses &gt; 0.0f. <br/>
 Static immobile obstacles, including buildings and terrains, have mass 0.0f. </td>
	</tr>
	<tr class="row3">
		<td class="col0"> setRestitution(0.0f) </td><td class="col1"> How bouncy the object is, e.g. rubber ball. This setting has an impact on performance. </td>
	</tr>
	<tr class="row4">
		<td class="col0"> setKinematic(true) </td><td class="col1"> A kinematic node is not affected by gravity, but it is solid and affects other physics objects. You can control its position using setLocalTranslation(), and you attach joints to it. </td>
	</tr>
	<tr class="row5">
		<td class="col0"> setCcdMotionThreshold(0.1f) </td><td class="col1"> The amount of motion in 1 physics tick to trigger the continuous motion detection. </td>
	</tr>
	<tr class="row6">
		<td class="col0"> setGravity(new Vector3f(0f,-1f,0f)) </td><td class="col1"> You can change the gravity of a physics node after it was added to the physics space. </td>
	</tr>
</table>
<table class="inline">
	<tr class="row0">
		<th class="col0"> PhysicsCharacterNode Method </th><th class="col1"> Property </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> setGravity(1f)   </td><td class="col1"> Gravity </td>
	</tr>
	<tr class="row2">
		<td class="col0"> setFallSpeed(1f) </td><td class="col1"> Fall speed (down) </td>
	</tr>
	<tr class="row3">
		<td class="col0"> setJumpSpeed(1f) </td><td class="col1"> Jump speed (up) </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> setMaxSlope(1.5f)   </td><td class="col1"> How steep the character can climb </td>
	</tr>
	<tr class="row5">
		<td class="col0"> setUpAxis(1)</td><td class="col1"> 0 = X axis , 1 = Y axis , 2 = Z axis. E.g. for characters and vehicle, up is usually along the the Y axis. </td>
	</tr>
</table>

</div>
<!-- SECTION "Properties of Physical Objects" [6832-8049] -->
<h3><a name="kinematic_vs_dynamic_vs_static" id="kinematic_vs_dynamic_vs_static">Kinematic vs Dynamic vs Static</a></h3>
<div class="level3">

<p>

All PhysicsNodes respond to collisions, and they cannot overlap. But you can create PhysicsNodes without mass. They are still treated as solid objects, but they cannot be dynamically pushed around – they act as static, immobile attached physical obstacles. 
</p>
<pre class="code java">airhook.<span class="me1">setKinematic</span><span class="br0">&#40;</span><span class="kw2">true</span><span class="br0">&#41;</span>;</pre>
<p>
Kinematic nodes are not affected by gravity, and they are not moved by other physical objects colliding with them. Colliding non-kinematic nodes will deflect from the kinematic node as expected. Kinematic nodes can be positioned, e.g. using setLocalTranslation() in the update() loop. You can basically hang them up in mid-air, and can attach other PhysicsNodes to them using <a href="/com/jme3/gde/core/docs/jme3/advanced/hinges_and_joints.html" class="wikilink1" title="jme3:advanced:hinges_and_joints">hinges and joints</a>. 
</p>

</div>
<!-- SECTION "Kinematic vs Dynamic vs Static" [8050-8813] -->
<h2><a name="forcesmoving_physical_objects" id="forcesmoving_physical_objects">Forces: Moving Physical Objects</a></h2>
<div class="level2">

<p>

Use the following methods to move physics nodes.

</p>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Method </th><th class="col1"> Property </th>
	</tr>
	<tr class="row1">
		<td class="col0"> setAngularVelocity(new Vector3f(0f,0f,1f)) </td><td class="col1"> Move an object to the side with constant speed </td>
	</tr>
	<tr class="row2">
		<td class="col0"> setLinearVelocity(new Vector3f(0f,0f,1f)) </td><td class="col1"> Move an object forward with constant speed </td>
	</tr>
	<tr class="row3">
		<td class="col0"> setWalkDirection(new Vector3f(0f,0f,0.1f))</td><td class="col1"> Make a physical character walk (characters are locked to prevent falling over) </td>
	</tr>
	<tr class="row4">
		<td class="col0"> applyCentralForce(…) </td><td class="col1 leftalign"> Move (push) the object once with a certain moment, expressed as a Vector3f.  </td>
	</tr>
	<tr class="row5">
		<td class="col0"> applyForce(…) </td><td class="col1"> Move (push) the object once with a certain moment, expressed as a Vector3f. Optionally, you can specify where on the object the pushing force hits. </td>
	</tr>
	<tr class="row6">
		<td class="col0"> applyContinuousForce(…) </td><td class="col1"> Keep moving (pushing) the object with continuous force in one direction, expressed as a Vector3f. Optionally, you can specifiy where on the object the pushing force hits. </td>
	</tr>
	<tr class="row7">
		<td class="col0"> applyTorque(…) </td><td class="col1"> Rotate (twist) the object once around its axes, expressed as a Vector3f. </td>
	</tr>
	<tr class="row8">
		<td class="col0"> applyContinuousTorque(…) </td><td class="col1"> Keep rotating (twisting) the object continuously around its axes, expressed as a Vector3f. </td>
	</tr>
	<tr class="row9">
		<td class="col0"> applyImpulse(…) </td><td class="col1"> An idealised change of momentum. This is the kind of push that you would use on a pool billiard ball. </td>
	</tr>
	<tr class="row10">
		<td class="col0"> applyTorqueImpulse(…) </td><td class="col1"> An idealised change of momentum. This is the kind of push that you would use on a pool billiard ball. </td>
	</tr>
</table>

<p>

Use <code>applyContinuousTorque(false)</code> and <code>applyContinuousForce(false)</code> to stop the torque/forces. Use <code>setWalkDirection(Vector3f.ZERO)</code> etc to stop a directional motion.
</p>

<p>
<strong>Note:</strong> It is possible to position physics nodes using setLocalTranslation(), e.g. to place them in their start position in the scene. However you must be very careful not to cause an “impossible state” where one physical object overlaps with another! Within the game, you typically use the setters shown here exclusively.
</p>

</div>
<!-- SECTION "Forces: Moving Physical Objects" [8814-10704] -->
<h2><a name="responding_to_a_physicscollisionevent" id="responding_to_a_physicscollisionevent">Responding to a PhysicsCollisionEvent</a></h2>
<div class="level2">

<p>

If you do not implement the PhysicsCollisionListener interface, a collisions will just mean that forces are applied automatically. If you just want “Balls rolling, bricks falling” you do not need a listener. 
</p>

<p>
If you want to respond to a collision event with a custom action however, then you need to implement the PhysicsCollisionListener interface. Typical actions triggered by collisions include:
</p>
<ul>
<li class="level1"><div class="li"> increasing a counter (score points)</div>
</li>
<li class="level1"><div class="li"> decreasing a counter (health points)</div>
</li>
<li class="level1"><div class="li"> triggering an effect (explosion)</div>
</li>
<li class="level1"><div class="li"> playing a sound (explosion, ouch) </div>
</li>
<li class="level1"><div class="li"> … and countless more</div>
</li>
</ul>

</div>
<!-- SECTION "Responding to a PhysicsCollisionEvent" [10705-11340] -->
<h3><a name="overriding_the_collision_method" id="overriding_the_collision_method">Overriding the Collision() Method</a></h3>
<div class="level3">

<p>

To respond to the PhysicsCollisionEvent you have to override the <code>collision()</code> method. This gives you access to the event object. Mostly you will be interested in the identity of any two nodes that collided: <code>event.getNodeA()</code> and <code>event.getNodeB()</code>. 
</p>

<p>
After you identify the colliding nodes, specify the action to trigger when this pair collides. Note that you cannot know which one will be Node A or Node B, you have to deal with either variant.
</p>
<pre class="code java">    <span class="kw1">public</span> <span class="kw4">void</span> collision<span class="br0">&#40;</span>PhysicsCollisionEvent event<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span> event.<span class="me1">getNodeA</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">getName</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">equals</span><span class="br0">&#40;</span><span class="st0">&quot;player&quot;</span><span class="br0">&#41;</span> <span class="br0">&#41;</span> <span class="br0">&#123;</span>
            <span class="kw1">final</span> Node node <span class="sy0">=</span> event.<span class="me1">getNodeA</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
            enqueue<span class="br0">&#40;</span><span class="kw1">new</span> Callable<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
                <span class="kw1">public</span> <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://www.google.com/search?hl=en&amp;q=allinurl%3Aobject+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky"><param name="text" value="<html><u></u></html>"><param name="textColor" value="blue"></object> <span class="br0">&#123;</span>
                    <span class="co3">/** ... do something with the node ... */</span>
                    <span class="kw1">return</span> <span class="kw2">null</span>;
                <span class="br0">&#125;</span>
            <span class="br0">&#125;</span><span class="br0">&#41;</span>;
        <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span> event.<span class="me1">getNodeB</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">getName</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">equals</span><span class="br0">&#40;</span><span class="st0">&quot;player&quot;</span><span class="br0">&#41;</span> <span class="br0">&#41;</span> <span class="br0">&#123;</span>
            <span class="kw1">final</span> Node node <span class="sy0">=</span> event.<span class="me1">getNodeB</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
            enqueue<span class="br0">&#40;</span><span class="kw1">new</span> Callable<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
                <span class="kw1">public</span> <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://www.google.com/search?hl=en&amp;q=allinurl%3Aobject+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky"><param name="text" value="<html><u></u></html>"><param name="textColor" value="blue"></object> <span class="br0">&#123;</span>
                    <span class="co3">/** ... do something with the node ... */</span>
                    <span class="kw1">return</span> <span class="kw2">null</span>;
                <span class="br0">&#125;</span>
            <span class="br0">&#125;</span><span class="br0">&#41;</span>;
        <span class="br0">&#125;</span>
    <span class="br0">&#125;</span></pre>
</div>
<!-- SECTION "Overriding the Collision() Method" [11341-12602] -->
<h3><a name="reading_details_from_a_physicscollisionevent" id="reading_details_from_a_physicscollisionevent">Reading Details From a PhysicsCollisionEvent</a></h3>
<div class="level3">

<p>

The PhysicsCollisionEvent <code>event</code> gives you access to detailed information about the collision. You already know the event objects can identify which nodes collided, but it even knows how hard they collided:

</p>
<table class="inline">
	<tr class="row0">
		<th class="col0 leftalign">Method                        </th><th class="col1">Purpose</th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> getNodeA() <br/>
 getNodeB()     </td><td class="col1"> The two participants in the collision. You cannot know in advance whether some node will be recorded as A or B, you always have to consider both cases. </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> getAppliedImpulse()          </td><td class="col1"> A float value representing the collision impulse </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> getAppliedImpulseLateral1()  </td><td class="col1"> A float value representing the lateral collision impulse </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> getAppliedImpulseLateral2()  </td><td class="col1"> A float value representing the lateral collision impulse </td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign"> getCombinedFriction()        </td><td class="col1"> A float value representing the collision friction </td>
	</tr>
	<tr class="row6">
		<td class="col0 leftalign"> getCombinedRestitution()     </td><td class="col1"> A float value representing the collision restitution (bounciness) </td>
	</tr>
</table>

<p>

Note that after the collision method has been called the object is not valid anymore so you should copy any data you want to keep into local variables.
</p>

</div>
<!-- SECTION "Reading Details From a PhysicsCollisionEvent" [12603-13705] -->
<h2><a name="best_practices" id="best_practices">Best Practices</a></h2>
<div class="level2">

<p>

Do not overuse physics nodes. Although the physics nodes are put to “sleep” when they are not moved, creating a world solely out of dynamic physics nodes will quickly bring you to the limits of your computer&#039;s capabilities. 
</p>

<p>
You can use normal non-physical Nodes in the same scene next to physical ones. Use the non-physical ones for non-solid things for which you do not want to detect collisions (ghost, foliage, plants, effects, …). This improves performance.
</p>

<p>
If you get weird behaviour, such as physical nodes jittering wildy and being ejected for no apparent reason, it usually means you have created an impossible state. Verify that none of the collision shapes overlap. This can happen when you create physical nodes in positions that are too close to other nodes; or if you position a physical node using setLocalTranslation() and it touches another node&#039;s collision shape.

</p>

</div>
<!-- SECTION "Best Practices" [13706-] -->
<p><em><a href="http://jmonkeyengine.org/wiki/doku.php/jme3:advanced:physics?do=export_xhtmlbody">view online version</a></em></p>