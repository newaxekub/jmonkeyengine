


<h1><a name="best_practices_for_jme3_developers" id="best_practices_for_jme3_developers">Best Practices For jME3 Developers</a></h1>
<div class="level1">

<p>

A collection of recommendations and expert tips. Feel free to add your own!
</p>

</div>
<!-- SECTION "Best Practices For jME3 Developers" [1-127] -->
<h2><a name="requirements_gathering" id="requirements_gathering">Requirements Gathering</a></h2>
<div class="level2">

<p>

First, <object classid="java:org.netbeans.modules.javahelp.BrowserDisplayer"><param name="content" value="http://www.google.com/search?q=game+design"><param name="text" value="<html><u>game developement</u></html>"><param name="textColor" value="blue"></object>. We cannot cover everything here, sorry. 
</p>

<p>

<strong>As a quick overview, answer yourself the following questions:</strong>
</p>
<ul>
<li class="level1"><div class="li"> Motivation</div>
<ul>
<li class="level2"><div class="li"> Sum up your game idea in one sentence. If you can&#039;t, it&#039;s too complicated.</div>
</li>
<li class="level2"><div class="li"> Who&#039;s the target group? Why would they choose your game over the million others that exist? </div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Game type</div>
<ul>
<li class="level2"><div class="li"> Point of view (camera)? What character(s) does the player control (if any)? </div>
</li>
<li class="level2"><div class="li"> Time- or turn-based? </div>
</li>
<li class="level2"><div class="li"> Genre, setting, background story? (If applicable)</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Gameplay</div>
<ul>
<li class="level2"><div class="li"> What is the start state, what is the end state? </div>
</li>
<li class="level2"><div class="li"> What resources does the player manage? E.g. speed, gold, health, “points”</div>
</li>
<li class="level2"><div class="li"> How does the player interact? Rules, challenges, game mechanics</div>
</li>
<li class="level2"><div class="li"> What state is considered winning, and what losing?</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Media assets</div>
<ul>
<li class="level2"><div class="li"> Which media will you need? How will you get this content? <br/>
 models, terrains; materials, textures; audio, sound, music; video; spoken/written dialog; levels, quests, stories; AI scripts </div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Interface </div>
<ul>
<li class="level2"><div class="li"> Can you achieve a high degree of input control? Even minor navigation and interaction glitches make the game unsolvable.</div>
</li>
<li class="level2"><div class="li"> Clearly reflect status and changes in game states. E.g. health/damage.</div>
</li>
<li class="level2"><div class="li"> Clearly reward good moves and discourage bad ones.</div>
</li>
</ul>
</li>
</ul>

</div>
<!-- SECTION "Requirements Gathering" [128-1617] -->
<h2><a name="planning_development_milestones" id="planning_development_milestones">Planning Development Milestones</a></h2>
<div class="level2">
<ol>
<li class="level1"><div class="li"> Pre-Alpha</div>
<ol>
<li class="level2"><div class="li"> Lay out the overall application flow using mock-ups or stock art. E.g. switching between intro screen / options screen / game screen.</div>
</li>
<li class="level2"><div class="li"> Get one typical level working. E.g. if it&#039;s a “Jump&#039;n&#039;Run”, jumping and running must work before you can call it an Alpha.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Alpha</div>
<ol>
<li class="level2"><div class="li"> Run internal tests, debug, optimize (issue tracker).</div>
</li>
<li class="level2"><div class="li"> Replace all mock-ups with first drafts of real media and levels.</div>
</li>
<li class="level2"><div class="li"> Feature Freeze: Avoid a bottomless pit of side effects causing new issues.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Beta</div>
<ol>
<li class="level2"><div class="li"> Have external people review and “beta test” it (issue tracker).</div>
</li>
<li class="level2"><div class="li"> Even out the kinks in the code – don&#039;t add any more new features.</div>
</li>
<li class="level2"><div class="li"> Fill in all final content.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Release Candidate</div>
<ol>
<li class="level2"><div class="li"> Last chance to find a horrible bug.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Final Release</div>
</li>
</ol>

<p>

How you actually name or number these milestones is up to you. People use the words “milestone”, Greek letters, versions, numbers, or combinations thereof.
</p>

<p>
Every milestone has a development phase and a test phase. Here are some best practices:
</p>

</div>
<!-- SECTION "Planning Development Milestones" [1618-2680] -->
<h2><a name="development_phase" id="development_phase">Development Phase</a></h2>
<div class="level2">

</div>
<!-- SECTION "Development Phase" [2681-2711] -->
<h3><a name="where_to_start" id="where_to_start">Where to Start?</a></h3>
<div class="level3">

<p>

Many ask, where do I start? You have a list of features that you want in, which one do you implement first? You will keep <em>adding features</em> to a project that grows more and more complex, how can you minimize the amount of rewriting required? 

</p>
<ol>
<li class="level1"><div class="li"> When laying out the base game, only add one bigger feature (physics, audio, etc) at a time. Complete and test one feature before you add the next. Test for side effects on existing code.</div>
</li>
<li class="level1"><div class="li"> Acknowledge whether you want to add a feature because it is necessary for gameplay, or simply “because it looks cool”. The most popular high-performance games are the ones where someone made a smart decision what to keep and what to drop. </div>
<ul>
<li class="level2"><div class="li"> Example: Everybody wants “full physics, AI, effects, plus multiplayer networking”. But do you have a realistic plan how to keep this all synchronized and playable? Bring out the essence of your game idea, don&#039;t water down gameplay with “cool things that other games have.” </div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> If there are complex interactions (such as networking+physics), start with a small test case (“one cube”) and work your way up, don&#039;t start with a whole scene.</div>
</li>
</ol>

<p>

Start with implementing the most complex game feature first, the one that imposes most constraints on the structure of your project. (See table below)
</p>
<ul>
<li class="level1"><div class="li"> Example - harder to add: In a solo game, one player character responds to all inputs. But in a networked game, the developer must abstract over all players/NPCs from the start. If you add networking last, you&#039;ll have to rewrite large chunks of code.</div>
</li>
<li class="level2"><div class="li"> Example - easier to add: When you allow your users to customize the inputs, you have to replace all hard-coded key constants with variables, and serialize them. A bit of work, but not difficult to do later on.</div>
</li>
</ul>

<p>

Here&#039;s a <em>suggested</em> order for implementing common features. (Your game is not expected to have all of them.) 

</p>
<table class="inline">
	<tr class="row0">
		<th class="col0">Desired game feature </th><th class="col1"> Technology to use </th><th class="col2"> Complexity to add this </th>
	</tr>
	<tr class="row1">
		<td class="col0">Multiplayer networking</td><td class="col1">SpiderMonkey client/server networking</td><td class="col2">high</td>
	</tr>
	<tr class="row2">
		<td class="col0">Artificial intelligence</td><td class="col1">?</td><td class="col2">high</td>
	</tr>
	<tr class="row3">
		<td class="col0">Physics</td><td class="col1">jBullet AppState integration</td><td class="col2">medium</td>
	</tr>
	<tr class="row4">
		<td class="col0">Screens: Saved Games, User settings, Highscores</td><td class="col1">Nifty <acronym title="Graphical User Interface">GUI</acronym>, Serialization</td><td class="col2">medium</td>
	</tr>
	<tr class="row5">
		<td class="col0">Scene-wide effects</td><td class="col1">Filters, prost processors</td><td class="col2">medium</td>
	</tr>
	<tr class="row6">
		<td class="col0">Water</td><td class="col1">SeaMonkey water simulation</td><td class="col2">low</td>
	</tr>
	<tr class="row7">
		<td class="col0">Input handling</td><td class="col1">Input manager and listener</td><td class="col2">low</td>
	</tr>
	<tr class="row8">
		<td class="col0">HUD</td><td class="col1">Nifty <acronym title="Graphical User Interface">GUI</acronym></td><td class="col2">low</td>
	</tr>
	<tr class="row9">
		<td class="col0">Animation</td><td class="col1">AnimChannel, AnimControl</td><td class="col2">low</td>
	</tr>
	<tr class="row10">
		<td class="col0">Terrain</td><td class="col1">TerraMonkey terrain builder</td><td class="col2">easy</td>
	</tr>
	<tr class="row11">
		<td class="col0">Local effects</td><td class="col1">Particle emitter, glow</td><td class="col2">easy</td>
	</tr>
	<tr class="row12">
		<td class="col0">Audio</td><td class="col1">jME Audio</td><td class="col2">easy</td>
	</tr>
	<tr class="row13">
		<td class="col0">Sky</td><td class="col1">Sky bucket</td><td class="col2">easy</td>
	</tr>
</table>

<p>

<strong>Note: This table is about the order of complexity to <em>add</em> certain features into existing code, not how difficult it is to <em>learn</em> these concepts.</strong>
</p>

<p>
Obviously every game project brings its own additional complexities. In general, make sure the game&#039;s generic frame (screen switching, networking, physics, loading/saving) is sound and solid before you invest effort into implementing gameplay and custom interactions. 
</p>

</div>
<!-- SECTION "Where to Start?" [2712-5661] -->
<h3><a name="extend_simpleapplication" id="extend_simpleapplication">Extend SimpleApplication</a></h3>
<div class="level3">

<p>

Typically developers create a custom class off of jME3&#039;s SimpleApplication. For a racing game you would create a different game class than for a space game or shooter.

</p>
<ol>
<li class="level1"><div class="li"> Create a custom game class for your type of game:</div>
<ol>
<li class="level3"><div class="li"> Create a new jME3 project. </div>
</li>
<li class="level3"><div class="li"> Create a new package for each type of game, e.g. <code>my.company.shooter</code>, <code>my.company.racing</code>. </div>
</li>
<li class="level3"><div class="li"> Create a class in this package that extends SimpleApplication, e.g. name it <code>my.company.shooter.ShooterBaseGame</code>.</div>
</li>
<li class="level3"><div class="li"> Add all generic game features that this type of games needs to your ShooterBaseGame class (e.g. physics, networking, loading and saving of scenes and settings, screen switching…) </div>
</li>
<li class="level3"><div class="li"> Include generic assets (company logo, reusable <acronym title="Graphical User Interface">GUI</acronym> elements in your company style, etc) in this ShooterBaseGame assets directory.</div>
</li>
</ol>
</li>
<li class="level2"><div class="li"> Create your game, e.g. a shooter: </div>
<ol>
<li class="level3"><div class="li"> Create a new jME3 project and a new package for each Shooter game, e.g. <code>my.company.zombieshooter</code>. </div>
</li>
<li class="level3"><div class="li"> Add ShooterBaseGame.jar to the classpath</div>
</li>
<li class="level3"><div class="li"> Make the game&#039;s main class extend ShooterBaseGame. </div>
</li>
<li class="level3"><div class="li"> The specific assets for each game go into the game&#039;s own assets folder.</div>
</li>
</ol>
</li>
</ol>

</div>
<!-- SECTION "Extend SimpleApplication" [5662-6858] -->
<h3><a name="use_an_assets_folder" id="use_an_assets_folder">Use an Assets Folder</a></h3>
<div class="level3">

<p>

Put your assets into subfolders of your project&#039;s <code>assets</code> directory. This is the default path where the assetManager looks for files. 
</p>
<pre class="code">
jMonkeyProjects/Pong/assets/    # Store assets here
jMonkeyProjects/Pong/build/     # jMP generates built classes here *
jMonkeyProjects/Pong/build.xml  # Customize Ant build script here
jMonkeyProjects/Pong/nbproject/ # jMP stores default build.xml and meta data *
jMonkeyProjects/Pong/dist/      # jMP generates executables here *
jMonkeyProjects/Pong/src/       # Store Java sources here
jMonkeyProjects/Pong/test/      # Store test classes here (optional)
(*) managed by jMonkeyPlatform, don&#039;t edit
</pre>
<ul>
<li class="level1"><div class="li"> Agree on a file and directory naming scheme with the designers.</div>
<ul>
<li class="level2"><div class="li"> Are there assets (models, sound files, …) that will be used interchangeably? Then name or number them in a way so that the developer can swap the assets by swapping part of the path string.</div>
</li>
<li class="level2"><div class="li"> Decide on naming standards for naming interactive parts of models (e.g. arms/legs in an animation).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Structure the subfolders of <code>assets</code> in any way that suits the project – but stick with one system. </div>
<ul>
<li class="level2"><div class="li"> Either keep all Textures together with their Ogre meshes in the Model directory.</div>
</li>
<li class="level2"><div class="li"> Or keep the Ogre meshes with their Textures in the Textures directory. (Recommended.)</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Place reusable Textures and Materials (the ones that you set programmatically) into the Textures and Materials directory, respectively.</div>
</li>
<li class="level1"><div class="li"> If different types of assets (materials, textures, models) belong together, create a parallel subdirectory structure for them: <code>Textures/vehicles/car/</code>, <code>Materials/vehicles/car/</code>, <code>Models/vehicles/car/</code></div>
</li>
</ul>

<p>

Here is an example of a commonly used directory structure:
</p>
<pre class="code">
jMonkeyProjects/Pong/assets/Interface/ # .font, .jpg, .png, .xml
jMonkeyProjects/Pong/assets/MatDefs/   # .j3md
jMonkeyProjects/Pong/assets/Materials/ # .j3m
jMonkeyProjects/Pong/assets/Models/    # .j3o
jMonkeyProjects/Pong/assets/Scenes/    # .j3o
jMonkeyProjects/Pong/assets/Shaders/   # .vert, .frag
jMonkeyProjects/Pong/assets/Sounds/    # .ogg, .wav
jMonkeyProjects/Pong/assets/Textures/  # .mesh.xml+.material, .mtl+.obj, .jpg, .png
</pre>

<p>
See also: <a href="/com/jme3/gde/core/docs/jme3/jmonkeyplatform/asset_packs.html" class="wikilink1" title="jme3:jmonkeyplatform:asset_packs">Asset Packs</a>
</p>

</div>
<!-- SECTION "Use an Assets Folder" [6859-9126] -->
<h3><a name="don_t_mess_with_geometric_state" id="don_t_mess_with_geometric_state">Don&#039;t Mess With Geometric State</a></h3>
<div class="level3">

<p>

Here are some tips especially for users who already know jME2. Automatic handling of the Geometric State has improved in jME3, and it is now a best practice to <em>not</em> mess with it.

</p>
<ul>
<li class="level1"><div class="li"> Do not call updateGeometricState() on anything but the root node!</div>
</li>
<li class="level1"><div class="li"> Do not override or mess with updateGeometricState() at all.</div>
</li>
<li class="level1"><div class="li"> Do not use getLocalTranslation().set() to move a spatial, always use setLocalTranslation().</div>
</li>
</ul>

</div>
<!-- SECTION "Don't Mess With Geometric State" [9127-9583] -->
<h3><a name="maintain_internal_documentation" id="maintain_internal_documentation">Maintain Internal Documentation</a></h3>
<div class="level3">

<p>

It&#039;s unlikely you will be willing to fully document every class you write. You should at minimum javadoc all crucial methods/parameters in a meaningful way. 

</p>
<ul>
<li class="level1"><div class="li"> Answer three questions for every crucial method/parameter:</div>
<ul>
<li class="level2"><div class="li"> What is this? </div>
</li>
<li class="level2"><div class="li"> How does it solve its task? (e.g. algorithm used)</div>
</li>
<li class="level2"><div class="li"> In which situation do I want to use this? </div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Write down limits (e.g. min/max values) and defaults while you still remember. </div>
</li>
<li class="level1"><div class="li"> Is this optional or required? What are the alternatives?</div>
</li>
<li class="level1"><div class="li"> Treat javadoc as messages to your future self. “genNextVal() generates the next value” and ”@param float factor A factor influencing the result” do <em>not</em> count as documentation. </div>
</li>
</ul>

</div>
<!-- SECTION "Maintain Internal Documentation" [9584-10305] -->
<h3><a name="use_version_control" id="use_version_control">Use Version Control</a></h3>
<div class="level3">

<p>

Whether you work in a team or alone, keeping a version controlled repository of your code will help you roll-back buggy changes. 
</p>
<ul>
<li class="level1"><div class="li"> Treat commit messages as messages to your future self. “Made some changes” is <em>not</em> a commit message.</div>
</li>
<li class="level1"><div class="li"> The jMonkeyPlatform supports Subversion, Mercurial, and <acronym title="Concurrent Versions System">CVS</acronym>. </div>
<ul>
<li class="level2"><div class="li"> If you don&#039;t know which to choose, Subversion is a good choice for starters. </div>
</li>
<li class="level2"><div class="li"> You can get free project hosting space from various open-source dev portals or Google Code.</div>
</li>
</ul>
</li>
</ul>

</div>
<!-- SECTION "Use Version Control" [10306-10823] -->
<h3><a name="convert_models_to_.j3o_format" id="convert_models_to_.j3o_format">Convert Models to .j3o Format</a></h3>
<div class="level3">

<p>

From the beta on, convert all Ogre mesh models and scenes to the binary .j3o format. Use the jMonkeyPlatform for the conversion, and save the .j3o files into the Models directory. 

</p>
<ul>
<li class="level1"><div class="li"> .j3o is an optimized format to store part of a jME3 scenegraph. <br/>
 It can contain an individual model or a whole scene. Optionally (using the jMonkeyEngine SceneComposer) you can include the model&#039;s physical properties, materials, lights, particle emitters, and audio nodes.</div>
</li>
<li class="level1"><div class="li"> If you kept the Ogre mesh together with the textures in the Textures directory during the conversion, the paths are recorded in a way so that you can move the .j3o to another directory, and it will still find its textures.</div>
</li>
<li class="level1"><div class="li"> The default Ant build script copies .j3o / .j3m files and other assets into the distributable JAR automatically. </div>
</li>
<li class="level1"><div class="li"> Important: Other model files however (.mesh.xml, .material, .obj, .mat) are not bundled automatically. You will get a runtime error that a resource was not found if you try to run the JAR with code referring to these files.  </div>
</li>
</ul>

</div>
<!-- SECTION "Convert Models to .j3o Format" [10824-11901] -->
<h2><a name="debugging_and_test_phase" id="debugging_and_test_phase">Debugging and Test Phase</a></h2>
<div class="level2">

</div>
<!-- SECTION "Debugging and Test Phase" [11902-11939] -->
<h3><a name="test" id="test">Test</a></h3>
<div class="level3">

<p>

Unit Tests (Java Assertions) have a different status in 3D graphics development than in other types of software. You cannot write any assertions that automatically test whether the rendered image looks correct, or whether interactions are intuitive. Still you should create simple test cases for separate game features such as loaders, content generators, effects. Run them now and then to see whether they still work as intended – or whether they are affected by side effects. Keep the test classes in a test directory in the project, but don&#039;t include them in the distribution.
</p>

<p>
Quality Assurance (QA) means maintaining a clear list of steps that must always work, and checking them. There can be bugs in software, but tasks such as installing and de-installing, saving and loading, starting/pausing/quitting the game, <em>must work</em>, no excuse. After every milestone, you go through the list again, on every supported operating system, and systematically look for regressions or bugs. 
</p>

<p>
Alpha and Beta Testing means that you ask someone to try to install and run your game. It should be a real user situation, where they are left to figure it out by themselves (you only can include the usual read-me and help docs). Provide the testers with an easy method to report back descriptions of their problems, e.g. why they gave up. Evaluate whether these problems are exceptions or must be fixed for the game to be playable. 
</p>

</div>
<!-- SECTION "Test" [11940-13380] -->
<h3><a name="debug" id="debug">Debug</a></h3>
<div class="level3">

<p>

A Java Debugger is included in the jMonkeyPlatform. It allows you to set a break point in your code near the point where an exception happens. Then you step through the execution line by line and watch object and variable states to detect where the bug starts.
</p>

</div>
<!-- SECTION "Debug" [13381-13659] -->
<h3><a name="enhance_performance" id="enhance_performance">Enhance Performance</a></h3>
<div class="level3">

<p>

A Java Profiler can be added to the jMonkeyPlatform via Tools → Plugins → Available. The profiler presents statistics on the lifecycle of methods and objects. Performance problems may be caused by just a few methods that take long, or are called too often. If object creation and garbage collection counts keep increasing, you are looking at a memory leak. 
</p>

</div>
<!-- SECTION "Enhance Performance" [13660-14052] -->
<h2><a name="release_phase" id="release_phase">Release Phase</a></h2>
<div class="level2">

<p>

Release requirements: When do I consider my game complete? 
</p>

<p>
…
</p>

<p>
Distributable Executable: WebStart, Desktop JAR, or Applet? Each has its pros and cons.

</p>
<table class="inline">
	<tr class="row0">
		<th class="col0">Distribution</th><th class="col1">Pros</th><th class="col2">Cons</th>
	</tr>
	<tr class="row1">
		<td class="col0">Web Start <br/>
 (JNLP)</td><td class="col1">The user accesses a <acronym title="Uniform Resource Locator">URL</acronym>, saves the game as one executable file. Easy process, no installer required. You can allow the game to be played offline.</td><td class="col2">Users need network connection to install the game. Downloading bigger games takes a while as opposed to running them from a CD. Your company must have a trusted certificate.</td>
	</tr>
	<tr class="row2">
		<td class="col0">Desktop Application <br/>
 (JAR)</td><td class="col1">Platform independent. Game can be distributed and started from any medium. Your company does not need a trusted certificate.</td><td class="col2">User must have Java configured to run JARs when they are opened; or user must know how to run JARs from command line; or you must provide a custom launcher script or JAR wrapper.</td>
	</tr>
	<tr class="row3">
		<td class="col0">Browser Applet <br/>
 (<acronym title="HyperText Markup Language">HTML</acronym>+JAR)</td><td class="col1">Easy to access and play game via most web browsers. Userfriendly solution for quick small games.</td><td class="col2">Game only runs in the browser. Game or settings cannot be saved to disk. Your company must have a trusted certificate. Some restrictions in default camera navigation (jME cannot capture mouse.)</td>
	</tr>
</table>

</div>
<!-- SECTION "Release Phase" [14053-] -->
<p><em><a href="http://jmonkeyengine.org/wiki/doku.php/jme3:intermediate:best_practices?do=export_xhtmlbody">view online version</a></em></p>